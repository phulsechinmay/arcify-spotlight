---
phase: 14-utility-module-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - test/mocks/chrome.js
  - test/unit/bookmark-utils.test.js
autonomous: true

must_haves:
  truths:
    - "bookmark-utils.js has exhaustive tests covering all 13 exported functions"
    - "Chrome mock includes getTree, remove, update, and tabs.group APIs"
    - "Tests cover the 3-method fallback in findArcifyFolder"
    - "Tests cover cache behavior in getAllBookmarks"
    - "Tests cover recursive traversal in getBookmarksFromFolderRecursive, findBookmarkInFolderRecursive, removeBookmarkByUrl, matchTabsWithBookmarks, and updateBookmarkTitle"
    - "Tests cover openBookmarkAsTab Chrome API calls and context function invocations"
    - "Tests cover pure utility functions: findBookmarkByUrl, findTabByUrl, isUnderArcifyFolder"
    - "Tests cover getBookmarksData with Arcify exclusion filtering"
    - "All tests pass with npx vitest run alongside existing 337+ tests"
  artifacts:
    - path: "test/mocks/chrome.js"
      provides: "Extended Chrome API mock with getTree, remove, update, tabs.group"
      contains: "bookmarks.getTree"
    - path: "test/unit/bookmark-utils.test.js"
      provides: "50-70 unit tests for BookmarkUtils"
      min_lines: 400
  key_links:
    - from: "test/unit/bookmark-utils.test.js"
      to: "bookmark-utils.js"
      via: "import { BookmarkUtils }"
      pattern: "import.*BookmarkUtils.*from.*bookmark-utils"
    - from: "test/unit/bookmark-utils.test.js"
      to: "test/mocks/chrome.js"
      via: "import { chromeMock }"
      pattern: "import.*chromeMock.*from.*mocks/chrome"
    - from: "test/mocks/chrome.js"
      to: "test/setup.js"
      via: "global chrome mock assignment"
      pattern: "globalThis.chrome"
---

<objective>
Extend the shared Chrome API mock with missing bookmark/tab APIs, then write exhaustive unit tests for BookmarkUtils (577 lines, 9% coverage) targeting 80%+ line coverage.

Purpose: bookmark-utils.js is the #1 risk priority module in the coverage audit -- 577 lines with only 9% coverage. It handles all Arcify bookmark operations and is critical to the extension's core functionality.
Output: Extended chrome mock + comprehensive bookmark-utils.test.js with 50-70 tests covering all 13 exported functions.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/14-utility-module-tests/14-CONTEXT.md
@.planning/phases/14-utility-module-tests/14-RESEARCH.md
@bookmark-utils.js
@test/mocks/chrome.js
@test/setup.js
@test/unit/arcify-provider.test.js (pattern reference for chromeMock usage and vi.mock for BookmarkUtils)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Chrome API mock with missing bookmark and tab APIs</name>
  <files>test/mocks/chrome.js</files>
  <action>
Add the four missing Chrome API stubs to `test/mocks/chrome.js` that bookmark-utils.js requires:

1. In the `chromeMock` object definition:
   - Add `getTree: vi.fn().mockResolvedValue([])` to `chromeMock.bookmarks` (after the existing `getSubTree`)
   - Add `remove: vi.fn().mockResolvedValue(undefined)` to `chromeMock.bookmarks` (after getTree)
   - Add `update: vi.fn().mockResolvedValue({})` to `chromeMock.bookmarks` (after remove)
   - Add `group: vi.fn().mockResolvedValue(1)` to `chromeMock.tabs` (after the existing `sendMessage`)

2. In the `resetChromeMocks()` function:
   - Add `chromeMock.bookmarks.getTree.mockClear().mockResolvedValue([]);` (after the existing getSubTree reset, around line 159)
   - Add `chromeMock.bookmarks.remove.mockClear().mockResolvedValue(undefined);` (after getTree reset)
   - Add `chromeMock.bookmarks.update.mockClear().mockResolvedValue({});` (after remove reset)
   - Add `chromeMock.tabs.group.mockClear().mockResolvedValue(1);` (after the existing tabs resets, around line 144)

Maintain the same formatting and ordering style as existing entries. Do NOT change any existing mock definitions or reset calls.
  </action>
  <verify>
Run `npx vitest run` from the project root. All existing 337+ tests must still pass (no regressions from mock changes). Verify the new APIs exist by checking: `grep -c 'getTree\|\.remove\|\.update\|\.group' test/mocks/chrome.js` should show the new entries.
  </verify>
  <done>
chrome.bookmarks.getTree, chrome.bookmarks.remove, chrome.bookmarks.update, and chrome.tabs.group are available as vi.fn() stubs in the shared mock, and their reset calls are in resetChromeMocks(). All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write exhaustive unit tests for BookmarkUtils</name>
  <files>test/unit/bookmark-utils.test.js</files>
  <action>
Create `test/unit/bookmark-utils.test.js` with exhaustive tests for all 13 exported functions of BookmarkUtils. Follow existing test patterns exactly (vitest imports, chromeMock imports, describe nesting, it.each for parameterized cases).

**File structure:**
```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { chromeMock } from '../mocks/chrome.js';

// Mock logger to prevent side effects and extra chrome.storage.sync.get calls
vi.mock('../../logger.js', () => ({
    Logger: {
        log: vi.fn(),
        warn: vi.fn(),
        error: vi.fn()
    }
}));

import { BookmarkUtils } from '../../bookmark-utils.js';
```

**Critical setup in beforeEach:**
```javascript
beforeEach(() => {
    BookmarkUtils.invalidateBookmarkCache();
});
```
This resets internal mutable state (`_bookmarkCache`, `_bookmarkCacheValid`). The global `resetChromeMocks()` in setup.js handles Chrome mock resets.

**IMPORTANT rules:**
- Never destructure methods from BookmarkUtils (breaks `this` binding)
- Always call async functions with `await` in `async` test callbacks
- Use `chromeMock.bookmarks.getChildren.mockImplementation()` with lookup tables for recursive traversal tests
- Use `chromeMock.bookmarks.search.mockResolvedValue()` for simple single-return mocks

**Test describe blocks and scenarios (cover ALL of these):**

**1. `invalidateBookmarkCache` (2-3 tests)**
- Resets cache so next getAllBookmarks fetches fresh
- Can be called multiple times without error

**2. `getAllBookmarks` (6-8 tests)**
- Fetches and flattens nested bookmark tree (nodes with URLs extracted, folders excluded)
- Returns cached results on second call (getTree called only once)
- After `invalidateBookmarkCache()`, fetches again (getTree called twice total)
- Handles empty tree (returns [])
- Handles deeply nested tree (3+ levels)
- Includes parentId in returned objects
- Returns [] on Chrome API error (mockRejectedValue)
- Excludes nodes without URLs (folders)

Use `chromeMock.bookmarks.getTree.mockResolvedValue([...])` with nested children structures. Example tree:
```javascript
[{
    id: '0', children: [{
        id: '1', title: 'Bookmarks Bar', children: [
            { id: '10', title: 'GitHub', url: 'https://github.com', parentId: '1' },
            { id: '11', title: 'Folder', children: [
                { id: '20', title: 'Nested', url: 'https://nested.com', parentId: '11' }
            ]}
        ]
    }]
}]
```

**3. `findArcifyFolder` (10-12 tests)**

Method 1 (search by title):
- Returns folder when search finds result without URL
- Skips results that have URLs (bookmarks, not folders)
- Returns first folder match when multiple results exist

Method 2 (tree traversal):
- Falls back to traversal when search returns empty array
- Finds Arcify folder in Bookmarks Bar
- Finds Arcify folder in Other Bookmarks
- Skips folder children that have URLs

Method 3 (Other Bookmarks specific):
- Falls back to Method 3 when Method 2 fails
- Finds Arcify in Other Bookmarks by id === '2'
- Finds Other Bookmarks by title containing 'other' (locale fallback)

Error handling:
- Returns null when all methods fail (no Arcify folder exists)
- Returns null when Chrome API throws (wrap search in mockRejectedValue)
- Handles getChildren error for individual root folders (continues to next)

Use `chromeMock.bookmarks.search.mockResolvedValue()` for Method 1, `chromeMock.bookmarks.getChildren.mockImplementation()` with lookup table for Methods 2-3.

**4. `getBookmarksFromFolderRecursive` (6-8 tests)**
- Returns bookmarks from flat folder (no subfolders)
- Recursively collects from nested subfolders
- Returns empty array for empty folder
- With `includeTabIds: true, groupId: 5`: adds tabId to matching bookmarks
- With `includeTabIds: true` but no matching tabs: bookmarks lack tabId property
- With `includeTabIds: false` (default): no tabs.query called

Use mockImplementation for getChildren with folder hierarchy. For tab matching tests, also mock `chromeMock.tabs.query.mockResolvedValue([...])`.

**5. `findBookmarkInFolderRecursive` (8-10 tests)**
- Finds bookmark by URL in direct children
- Finds bookmark by title in direct children
- Finds bookmark by URL in nested subfolder
- Returns result with bookmark, parentFolderId, and folderPath properties
- Returns null when bookmark not found
- Returns null when folderId is falsy
- Returns null when both url and title are missing from searchCriteria
- Returns null on Chrome API error
- Matches by URL OR title (not AND) -- if title matches, URL doesn't need to

Use mockImplementation for getChildren with nested tree structure.

**6. `findBookmarkByUrl` (5-6 tests)**
- Returns matching bookmark from array
- Returns null when no match
- Returns null when bookmarks is null
- Returns null when url is null
- Skips bookmarks without url property
- Returns first match when multiple exist

**7. `findTabByUrl` (5-6 tests)**
- Returns matching tab from array
- Returns null when no match
- Returns null when tabs is null
- Returns null when url is null
- Skips tabs without url property

**8. `openBookmarkAsTab` (6-8 tests)**
Create a minimal context object with vi.fn() stubs:
```javascript
const mockContext = {
    spaces: [{ id: 5, name: 'Work', spaceBookmarks: [] }],
    activeSpaceId: 5,
    currentWindow: { id: 1 },
    saveSpaces: vi.fn(),
    createTabElement: vi.fn().mockResolvedValue({
        classList: { add: vi.fn() },
        replaceWith: vi.fn()
    }),
    activateTabInDOM: vi.fn(),
    Utils: {
        setTabNameOverride: vi.fn().mockResolvedValue(undefined),
        setPinnedTabState: vi.fn().mockResolvedValue(undefined)
    },
    reconcileSpaceTabOrdering: vi.fn().mockResolvedValue(undefined)
};
```

Test scenarios:
- Creates tab with correct URL and windowId via chrome.tabs.create
- Groups tab into target space via chrome.tabs.group
- Calls Utils.setTabNameOverride when bookmark title differs from tab title
- Does NOT call setTabNameOverride when titles match
- For pinned tabs (isPinned=true): pushes to space.spaceBookmarks, calls saveSpaces, calls setPinnedTabState
- Calls reconcileSpaceTabOrdering with correct arguments
- Calls activateTabInDOM with new tab ID
- Returns the created tab object

Mock `chromeMock.tabs.create.mockResolvedValue({ id: 42, title: 'Tab Title', favIconUrl: '' })`.

**9. `removeBookmarkByUrl` (5-6 tests)**
- Finds and removes bookmark by URL in direct children, returns true
- Finds and removes bookmark in nested subfolder, returns true
- Returns false when bookmark URL not found
- Calls chrome.bookmarks.remove with correct bookmark ID
- With `logRemoval: true`: calls Logger.log (mocked)
- Does NOT call tabElement.remove() when removeTabElement is false

**10. `matchTabsWithBookmarks` (5-6 tests)**
- Returns array of tab IDs that match bookmark URLs
- Handles nested folders recursively
- Returns empty array when no tabs match
- Calls setTabNameOverride when bookmark title differs from tab title
- Does NOT call setTabNameOverride when titles match or setTabNameOverride is null

Mock both `chromeMock.bookmarks.getChildren` and `chromeMock.tabs.query`.

**11. `updateBookmarkTitle` (6-8 tests)**
- Updates bookmark title when found and title differs
- Skips update when title already matches (chrome.bookmarks.update NOT called)
- Returns false when Arcify folder not found
- Returns false when space folder not found
- Returns false when bookmark URL not found in space folder
- Handles nested subfolders within space folder
- Returns false on Chrome API error

This function calls `this.findArcifyFolder()` internally. Instead of mocking findArcifyFolder, mock the underlying Chrome APIs that findArcifyFolder uses (search returns Arcify folder, getChildren returns space folder children). Use mockImplementation for getChildren to handle multiple folderId calls.

**12. `isUnderArcifyFolder` (4-5 tests)**
- Returns true when parentId equals arcifyFolderId
- Returns true when parentId starts with arcifyFolderId
- Returns false when parentId is different
- Returns false when parentId is null/undefined

**13. `getBookmarksData` (5-6 tests)**
- Returns bookmarks filtered to exclude Arcify folder bookmarks
- Includes bookmarks with URLs outside Arcify folder
- Excludes folder nodes (no url property)
- Returns [] when Chrome API throws
- Works correctly when no Arcify folder exists (no exclusion applied)

This function calls `this.findArcifyFolder()` internally -- mock the underlying Chrome APIs (search + getChildren).

**Total: ~50-70 tests across all 13 functions.**
  </action>
  <verify>
Run `npx vitest run test/unit/bookmark-utils.test.js` -- all tests pass. Then run `npx vitest run` -- all tests (existing + new) pass with no regressions. Run `npx vitest run --coverage` and check bookmark-utils.js line coverage is 80%+.
  </verify>
  <done>
bookmark-utils.test.js exists with 50-70 passing tests covering all 13 exported functions. Coverage for bookmark-utils.js is 80%+ line coverage. All existing tests still pass (no regressions). Tests follow existing patterns (vitest, chromeMock, describe nesting, async/await).
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run` -- all tests pass (existing + new bookmark-utils tests), zero failures
2. `npx vitest run --coverage` -- bookmark-utils.js shows 80%+ line coverage
3. Chrome mock file has getTree, remove, update, tabs.group stubs and corresponding resetChromeMocks entries
4. test/unit/bookmark-utils.test.js exists and covers all 13 exported functions with describe blocks
5. No test uses destructured BookmarkUtils methods (always `BookmarkUtils.methodName()`)
6. beforeEach includes `BookmarkUtils.invalidateBookmarkCache()` to reset internal state
</verification>

<success_criteria>
- bookmark-utils.js has 80%+ line coverage (up from 9%)
- All 13 exported functions have dedicated describe blocks with passing tests
- Chrome mock extended with 4 missing APIs, no regressions in existing tests
- Total test count increases by 50-70 tests
</success_criteria>

<output>
After completion, create `.planning/phases/14-utility-module-tests/14-01-SUMMARY.md`
</output>
