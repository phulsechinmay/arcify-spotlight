---
phase: 11-performance
plan: 03
type: execute
wave: 3
depends_on: ["11-01", "11-02"]
files_modified:
  - test/unit/search-engine-debounce.test.js
  - test/unit/search-engine-cache.test.js
autonomous: true

must_haves:
  truths:
    - "Debounce tests validate that getSpotlightSuggestionsUsingCache still debounces correctly (the method still exists)"
    - "Cache tests validate that caching works for identical queries within TTL"
    - "All existing test assertions that remain valid continue to pass"
    - "npm test passes with zero failures"
  artifacts:
    - path: "test/unit/search-engine-debounce.test.js"
      provides: "Updated debounce tests for SearchEngine"
    - path: "test/unit/search-engine-cache.test.js"
      provides: "Updated cache tests for SearchEngine"
  key_links:
    - from: "test/unit/search-engine-debounce.test.js"
      to: "shared/search-engine.js"
      via: "Tests getSpotlightSuggestionsUsingCache debounce behavior"
      pattern: "getSpotlightSuggestionsUsingCache"
    - from: "test/unit/search-engine-cache.test.js"
      to: "shared/search-engine.js"
      via: "Tests cache hit/miss/TTL behavior"
      pattern: "getSpotlightSuggestionsUsingCache"
---

<objective>
Update existing debounce and cache tests to reflect the new single-debounce architecture and add tests for the progressive rendering pipeline.

Purpose: Plan 01 changed the background handler from `getSpotlightSuggestionsUsingCache` to `getSpotlightSuggestionsImmediate`, which means the debounce tests should be reviewed and updated. The SearchEngine's debounce method (`getSpotlightSuggestionsUsingCache`) still exists and still debounces -- it's just no longer called from the background handler. Tests for that method should remain valid. Cache tests should also be reviewed since the cache interacts with debounce.

Output: Updated test files with all tests passing, confirming the performance optimizations work correctly.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-performance/11-RESEARCH.md
@.planning/phases/11-performance/11-01-SUMMARY.md
@.planning/phases/11-performance/11-02-SUMMARY.md

@shared/search-engine.js
@shared/data-providers/base-data-provider.js
@test/unit/search-engine-debounce.test.js
@test/unit/search-engine-cache.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Review and update debounce tests</name>
  <files>test/unit/search-engine-debounce.test.js</files>
  <action>
The `getSpotlightSuggestionsUsingCache` method still exists and still debounces internally -- it's just no longer called from background.js. So the existing 11 debounce tests should STILL PASS as-is because they test the SearchEngine method directly, not the background handler.

Run `npm test -- test/unit/search-engine-debounce.test.js` first to confirm all 11 tests still pass.

If all pass: Add a comment block at the top of the describe noting the architectural context:
```javascript
// NOTE: As of Phase 11, getSpotlightSuggestionsUsingCache is no longer called from
// background.js (which uses getSpotlightSuggestionsImmediate instead). The UI-layer
// debounce in SharedSpotlightLogic.createInputHandler() is the single debounce point.
// These tests verify the method's internal debounce behavior is preserved.
```

Then add a new test section for `getSpotlightSuggestionsImmediate` to verify the immediate path works correctly:

```javascript
describe('SearchEngine.getSpotlightSuggestionsImmediate', () => {
    let engine;
    let mockProvider;

    beforeEach(() => {
        mockProvider = {
            isBackgroundProvider: true,
            getSpotlightSuggestions: vi.fn().mockResolvedValue([
                { type: 'open-tab', title: 'Test', url: 'https://test.com' }
            ])
        };
        engine = new SearchEngine(mockProvider);
    });

    it('calls provider immediately without debounce delay', async () => {
        const results = await engine.getSpotlightSuggestionsImmediate('test', SpotlightTabMode.CURRENT_TAB);

        expect(mockProvider.getSpotlightSuggestions).toHaveBeenCalledTimes(1);
        expect(mockProvider.getSpotlightSuggestions).toHaveBeenCalledWith('test', SpotlightTabMode.CURRENT_TAB);
        expect(results).toEqual([{ type: 'open-tab', title: 'Test', url: 'https://test.com' }]);
    });

    it('returns empty array on provider error', async () => {
        mockProvider.getSpotlightSuggestions.mockRejectedValue(new Error('Provider error'));

        const results = await engine.getSpotlightSuggestionsImmediate('test', SpotlightTabMode.CURRENT_TAB);

        expect(results).toEqual([]);
    });

    it('trims query before passing to provider', async () => {
        await engine.getSpotlightSuggestionsImmediate('  test  ', SpotlightTabMode.CURRENT_TAB);

        expect(mockProvider.getSpotlightSuggestions).toHaveBeenCalledWith('test', SpotlightTabMode.CURRENT_TAB);
    });

    it('uses CURRENT_TAB as default mode', async () => {
        await engine.getSpotlightSuggestionsImmediate('test');

        expect(mockProvider.getSpotlightSuggestions).toHaveBeenCalledWith('test', SpotlightTabMode.CURRENT_TAB);
    });
});
```

Also add a new describe block for `getLocalSuggestionsImmediate` (added by Plan 02):

```javascript
describe('SearchEngine.getLocalSuggestionsImmediate', () => {
    let engine;
    let mockProvider;

    beforeEach(() => {
        mockProvider = {
            isBackgroundProvider: true,
            getSpotlightSuggestions: vi.fn().mockResolvedValue([]),
            getLocalSuggestions: vi.fn().mockResolvedValue([
                { type: 'open-tab', title: 'Local Tab', url: 'https://local.com' }
            ])
        };
        engine = new SearchEngine(mockProvider);
    });

    it('calls dataProvider.getLocalSuggestions for local-only results', async () => {
        const results = await engine.getLocalSuggestionsImmediate('test', SpotlightTabMode.CURRENT_TAB);

        expect(mockProvider.getLocalSuggestions).toHaveBeenCalledTimes(1);
        expect(mockProvider.getLocalSuggestions).toHaveBeenCalledWith('test', SpotlightTabMode.CURRENT_TAB);
        expect(results).toEqual([{ type: 'open-tab', title: 'Local Tab', url: 'https://local.com' }]);
    });

    it('returns empty array on provider error', async () => {
        mockProvider.getLocalSuggestions.mockRejectedValue(new Error('Local error'));

        const results = await engine.getLocalSuggestionsImmediate('test', SpotlightTabMode.CURRENT_TAB);

        expect(results).toEqual([]);
    });
});
```

If any existing tests fail: Investigate why and fix. The most likely reason would be if the mock structure changed. Do NOT delete passing tests -- only add new ones.
  </action>
  <verify>
Run `npm test -- test/unit/search-engine-debounce.test.js` -- all tests (existing + new) must pass.
  </verify>
  <done>
All 11 original debounce tests pass. New tests for `getSpotlightSuggestionsImmediate` (4 tests) and `getLocalSuggestionsImmediate` (2 tests) pass. Architecture context comment added.
  </done>
</task>

<task type="auto">
  <name>Task 2: Review and update cache tests</name>
  <files>test/unit/search-engine-cache.test.js</files>
  <action>
The cache tests all test `getSpotlightSuggestionsUsingCache`, which still exists with its cache and debounce. These 5 tests should still pass as-is.

Run `npm test -- test/unit/search-engine-cache.test.js` first to confirm all 5 tests still pass.

If all pass: Add the same architectural context comment:
```javascript
// NOTE: As of Phase 11, getSpotlightSuggestionsUsingCache is no longer called from
// background.js, but the cache mechanism is preserved for backward compatibility.
// These tests verify the caching behavior is intact.
```

No new cache tests are needed because:
- `getSpotlightSuggestionsImmediate` does not use a cache (by design -- it's immediate)
- `getLocalSuggestionsImmediate` does not use a cache (by design)
- The autocomplete provider has its own internal cache (tested separately)

If any tests fail: Debug and fix. The cache tests depend on the debounce timer (they advance timers past 150ms to trigger the cached fetch), so they should still work since `getSpotlightSuggestionsUsingCache` is unchanged.

After all tests pass, run the FULL test suite:
```bash
npm test
```

Confirm zero failures across the entire test suite.
  </action>
  <verify>
Run `npm test` -- ALL tests across the entire suite must pass with zero failures.
  </verify>
  <done>
All 5 cache tests pass. Full test suite passes with zero failures. Performance phase test updates are complete.
  </done>
</task>

</tasks>

<verification>
1. `npm test -- test/unit/search-engine-debounce.test.js` -- all tests pass (11 original + 6 new)
2. `npm test -- test/unit/search-engine-cache.test.js` -- all 5 tests pass
3. `npm test` -- full suite passes with zero failures
4. No existing tests were deleted or modified in a way that weakens coverage
</verification>

<success_criteria>
- All original 16 tests (11 debounce + 5 cache) still pass
- 6 new tests added for immediate and local suggestion paths
- Full test suite (npm test) passes with zero failures
- Architecture context comments added for future maintainability
</success_criteria>

<output>
After completion, create `.planning/phases/11-performance/11-03-SUMMARY.md`
</output>
