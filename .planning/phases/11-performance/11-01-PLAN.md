---
phase: 11-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/data-providers/base-data-provider.js
  - shared/search-engine.js
  - background.js
autonomous: true

must_haves:
  truths:
    - "All 6 data sources in getSpotlightSuggestions() are fetched in parallel via Promise.allSettled(), not sequentially"
    - "The background.js handler for getSpotlightSuggestions calls getSpotlightSuggestionsImmediate() for all queries, not getSpotlightSuggestionsUsingCache()"
    - "Only the UI-layer debounce (150ms in SharedSpotlightLogic.createInputHandler) exists between keystroke and search execution"
  artifacts:
    - path: "shared/data-providers/base-data-provider.js"
      provides: "Parallel data fetching via Promise.allSettled"
      contains: "Promise.allSettled"
    - path: "background.js"
      provides: "Direct routing to immediate search (no double debounce)"
      contains: "getSpotlightSuggestionsImmediate"
  key_links:
    - from: "background.js"
      to: "shared/search-engine.js"
      via: "getSpotlightSuggestionsImmediate (not getSpotlightSuggestionsUsingCache)"
      pattern: "getSpotlightSuggestionsImmediate"
    - from: "shared/search-engine.js"
      to: "shared/data-providers/base-data-provider.js"
      via: "getSuggestionsImpl -> dataProvider.getSpotlightSuggestions"
      pattern: "getSpotlightSuggestions"
---

<objective>
Parallelize data source fetching and eliminate double debouncing in the search pipeline.

Purpose: Currently 6 data sources are fetched sequentially (creating a waterfall) and two 150ms debounce layers stack to ~300ms effective delay. This plan replaces the sequential awaits with Promise.allSettled() and routes the background message handler through the immediate path (no SearchEngine debounce), halving perceived latency.

Output: Modified base-data-provider.js with parallel fetching, modified background.js calling immediate path, SearchEngine cache retained but debounce bypassed for message handler path.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-performance/11-RESEARCH.md

@shared/data-providers/base-data-provider.js
@shared/search-engine.js
@background.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Parallelize data source fetching with Promise.allSettled</name>
  <files>shared/data-providers/base-data-provider.js</files>
  <action>
In `BaseDataProvider.getSpotlightSuggestions()` (lines 48-142), replace the 6 sequential try/catch blocks (lines 66-113) with a single `Promise.allSettled()` call.

Replace:
```javascript
let openTabs = [];
let pinnedTabs = [];
// ... (6 sequential try/catch blocks)
```

With:
```javascript
const settled = await Promise.allSettled([
    this.getOpenTabs(trimmedQuery),
    this.getPinnedTabSuggestions(trimmedQuery),
    this.getBookmarkSuggestions(trimmedQuery),
    this.getHistorySuggestions(trimmedQuery),
    this.getTopSites(),
    this.getAutocompleteSuggestions(trimmedQuery),
]);

const [openTabs, pinnedTabs, bookmarks, history, topSites, autocomplete] =
    settled.map(result => {
        if (result.status === 'fulfilled') return result.value;
        Logger.error('[SearchProvider] Source failed:', result.reason);
        return [];
    });
```

Keep ALL code after line 113 (allResults assembly, dedup, enrich, score) completely unchanged. The variable names `openTabs`, `pinnedTabs`, `bookmarks`, `history`, `topSites`, `autocomplete` must remain identical for downstream code compatibility.

Do NOT change getDefaultResults(), individual data fetcher methods, or any other method on BaseDataProvider.
  </action>
  <verify>
Run `npm test` -- all existing tests should still pass since the method signature and return values are unchanged. The only behavioral change is execution order (parallel vs sequential), which tests don't depend on.
  </verify>
  <done>
The 6 data sources are fetched in parallel via Promise.allSettled(). Individual source failures are caught and logged without affecting other sources. The rest of the pipeline (dedup, enrich, score, sort) is unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Eliminate double debouncing by routing background handler through immediate path</name>
  <files>background.js, shared/search-engine.js</files>
  <action>
In `background.js`, find the `getSpotlightSuggestions` message handler (around line 388-401). Change it to always use `getSpotlightSuggestionsImmediate()` instead of the current conditional that uses `getSpotlightSuggestionsUsingCache()` for non-empty queries.

Replace:
```javascript
const results = query
    ? await backgroundSearchEngine.getSpotlightSuggestionsUsingCache(query, message.mode)
    : await backgroundSearchEngine.getSpotlightSuggestionsImmediate('', message.mode);
```

With:
```javascript
const results = await backgroundSearchEngine.getSpotlightSuggestionsImmediate(
    query, message.mode
);
```

This eliminates the second 150ms debounce in SearchEngine. The UI-layer debounce (150ms in `SharedSpotlightLogic.createInputHandler()`) remains as the single debounce point.

**Important:** Do NOT remove `getSpotlightSuggestionsUsingCache()` from SearchEngine or remove the cache. The method still exists and the cache is still useful for potential future use. Only the background handler routing changes. Do NOT modify `shared-component-logic.js` -- the UI-layer debounce stays exactly as-is.

In `shared/search-engine.js`, no production code changes are needed. The `getSpotlightSuggestionsUsingCache` method remains available but is no longer called from the main message handler path. Optionally add a comment noting the method is kept for backward compatibility but the background handler now uses the immediate path.
  </action>
  <verify>
Run `npm test` -- some debounce tests in `test/unit/search-engine-debounce.test.js` may still pass since they test SearchEngine directly (not background.js). The cache tests should still pass since the cache mechanism itself is unchanged. Note: test updates for the new behavior will be handled in Plan 03.

Manually verify: In background.js, the `getSpotlightSuggestions` handler now calls `getSpotlightSuggestionsImmediate()` for all queries.
  </verify>
  <done>
The background.js handler for `getSpotlightSuggestions` always calls `getSpotlightSuggestionsImmediate()`. The double debounce is eliminated -- only the UI-layer 150ms debounce in `SharedSpotlightLogic.createInputHandler()` exists. The SearchEngine cache and `getSpotlightSuggestionsUsingCache()` method remain intact for backward compatibility.
  </done>
</task>

</tasks>

<verification>
1. `npm test` passes (or only debounce-specific tests fail, which Plan 03 will update)
2. In `base-data-provider.js`, `getSpotlightSuggestions()` uses `Promise.allSettled()` for all 6 data sources
3. In `background.js`, the `getSpotlightSuggestions` handler calls `getSpotlightSuggestionsImmediate()` unconditionally
4. `getSpotlightSuggestionsUsingCache()` still exists in search-engine.js (not deleted)
5. `SharedSpotlightLogic.createInputHandler()` in shared-component-logic.js is NOT modified
</verification>

<success_criteria>
- Promise.allSettled wraps all 6 data source calls in base-data-provider.js
- background.js routes all queries through getSpotlightSuggestionsImmediate
- Only one debounce layer exists (UI-layer 150ms)
- All downstream code (dedup, enrich, score) unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/11-performance/11-01-SUMMARY.md`
</output>
