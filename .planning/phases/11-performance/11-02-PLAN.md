---
phase: 11-performance
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - shared/data-providers/base-data-provider.js
  - shared/message-client.js
  - background.js
  - overlay.js
  - newtab.js
autonomous: true

must_haves:
  truths:
    - "Local results (tabs, bookmarks, history, top sites) render immediately without waiting for autocomplete"
    - "Autocomplete suggestions append into the existing results list when they arrive from the network"
    - "When the user types a new query before autocomplete returns, stale autocomplete responses are discarded (not rendered)"
    - "Autocomplete results are deduplicated against local results before merging"
    - "The merged set is re-scored and re-sorted so autocomplete results appear at correct rank positions"
  artifacts:
    - path: "shared/data-providers/base-data-provider.js"
      provides: "getLocalSuggestions() method for fast local-only results"
      contains: "getLocalSuggestions"
    - path: "shared/message-client.js"
      provides: "getLocalSuggestions() and getAutocompleteSuggestions() static methods"
      contains: "getLocalSuggestions"
    - path: "background.js"
      provides: "getLocalSuggestions and getAutocompleteSuggestions message handlers"
      contains: "getLocalSuggestions"
    - path: "overlay.js"
      provides: "Two-phase search: local first, autocomplete appends"
      contains: "getLocalSuggestions"
    - path: "newtab.js"
      provides: "Two-phase search: local first, autocomplete appends"
      contains: "getLocalSuggestions"
  key_links:
    - from: "overlay.js"
      to: "shared/message-client.js"
      via: "SpotlightMessageClient.getLocalSuggestions() and getAutocompleteSuggestions()"
      pattern: "getLocalSuggestions"
    - from: "shared/message-client.js"
      to: "background.js"
      via: "chrome.runtime.sendMessage with action getLocalSuggestions / getAutocompleteSuggestions"
      pattern: "getLocalSuggestions|getAutocompleteSuggestions"
    - from: "background.js"
      to: "shared/data-providers/base-data-provider.js"
      via: "dataProvider.getLocalSuggestions() for fast path"
      pattern: "getLocalSuggestions"
---

<objective>
Implement progressive rendering so local results display immediately while autocomplete appends when ready.

Purpose: Currently all 6 data sources are fetched as a single batch, and nothing renders until the slowest source (autocomplete, ~200-500ms network) completes. Splitting into two phases lets local results (~10-50ms) render instantly while autocomplete appends asynchronously. This eliminates the perception of "waiting" on every keystroke.

Output: New `getLocalSuggestions()` method on BaseDataProvider, new message types in background.js and message-client.js, two-phase search flow in overlay.js and newtab.js with stale query protection.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-performance/11-RESEARCH.md
@.planning/phases/11-performance/11-01-SUMMARY.md

@shared/data-providers/base-data-provider.js
@shared/message-client.js
@shared/search-engine.js
@background.js
@overlay.js
@newtab.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getLocalSuggestions() to BaseDataProvider and wire through SearchEngine + background + message-client</name>
  <files>shared/data-providers/base-data-provider.js, shared/search-engine.js, background.js, shared/message-client.js</files>
  <action>
**Step 1: BaseDataProvider.getLocalSuggestions()**

Add a new method `getLocalSuggestions(query, mode)` to BaseDataProvider that fetches ONLY local sources (no autocomplete). This method should:

1. Trim and lowercase the query. If empty, delegate to `getDefaultResults(mode)`.
2. Use `Promise.allSettled()` to fetch in parallel: `getOpenTabs`, `getPinnedTabSuggestions`, `getBookmarkSuggestions`, `getHistorySuggestions`, `getTopSites`.
3. Extract results with the same `settled.map(r => r.status === 'fulfilled' ? r.value : [])` pattern.
4. Assemble allResults from the 5 local sources (same pattern as getSpotlightSuggestions but WITHOUT autocomplete).
5. Add matching top sites and fuzzy domain matches (same as existing code).
6. Run `deduplicateResults()`, `enrichWithArcifyInfo()`, `scoreAndSortResults()` on the combined local results.
7. Return the scored and sorted local results.

Place this method directly after `getSpotlightSuggestions()` in the class. The existing `getSpotlightSuggestions()` method should remain unchanged (it already uses Promise.allSettled from Plan 01).

**Step 2: SearchEngine.getLocalSuggestionsImmediate()**

Add a new method to SearchEngine:
```javascript
async getLocalSuggestionsImmediate(query, mode = SpotlightTabMode.CURRENT_TAB) {
    try {
        const trimmedQuery = query.trim();
        const results = await this.dataProvider.getLocalSuggestions(trimmedQuery, mode);
        return results;
    } catch (error) {
        Logger.error('[SearchEngine] Local suggestions error:', error);
        return [];
    }
}
```

Place it after `getSpotlightSuggestionsImmediate()`.

**Step 3: Background.js message handlers**

Add TWO new message handlers in background.js, adjacent to the existing `getSpotlightSuggestions` handler:

Handler 1 - `getLocalSuggestions`:
```javascript
} else if (message.action === 'getLocalSuggestions') {
    (async () => {
        try {
            const query = message.query.trim();
            const results = await backgroundSearchEngine.getLocalSuggestionsImmediate(
                query, message.mode
            );
            sendResponse({ success: true, results: results });
        } catch (error) {
            Logger.error('[Background] Error getting local suggestions:', error);
            sendResponse({ success: false, error: error.message, results: [] });
        }
    })();
    return true;
```

Handler 2 - `getAutocompleteSuggestions`:
```javascript
} else if (message.action === 'getAutocompleteSuggestions') {
    (async () => {
        try {
            const query = message.query.trim();
            const results = query
                ? await backgroundDataProvider.getAutocompleteSuggestions(query)
                : [];
            sendResponse({ success: true, results: results });
        } catch (error) {
            Logger.error('[Background] Error getting autocomplete suggestions:', error);
            sendResponse({ success: false, error: error.message, results: [] });
        }
    })();
    return true;
```

Note: The autocomplete handler calls `backgroundDataProvider.getAutocompleteSuggestions()` directly (the BaseDataProvider method), NOT SearchEngine, because autocomplete is a simple pass-through that doesn't need SearchEngine orchestration.

**Step 4: SpotlightMessageClient**

Add two new static methods to `SpotlightMessageClient` in message-client.js:

```javascript
// Get local suggestions only (fast, no autocomplete)
static async getLocalSuggestions(query, mode) {
    try {
        const response = await chrome.runtime.sendMessage({
            action: 'getLocalSuggestions',
            query: query.trim(),
            mode: mode
        });
        if (response && response.success) {
            return response.results;
        } else {
            Logger.error('[SpotlightMessageClient] Get local suggestions failed:', response?.error);
            return [];
        }
    } catch (error) {
        Logger.error('[SpotlightMessageClient] Get local suggestions error:', error);
        return [];
    }
}

// Get autocomplete suggestions only (slow, network)
static async getAutocompleteSuggestions(query) {
    try {
        const response = await chrome.runtime.sendMessage({
            action: 'getAutocompleteSuggestions',
            query: query.trim()
        });
        if (response && response.success) {
            return response.results;
        } else {
            Logger.error('[SpotlightMessageClient] Get autocomplete suggestions failed:', response?.error);
            return [];
        }
    } catch (error) {
        Logger.error('[SpotlightMessageClient] Get autocomplete suggestions error:', error);
        return [];
    }
}
```

Place these after the existing `getSuggestions()` method. The existing `getSuggestions()` method stays intact (backward compatibility for the original all-in-one path).

**Important:** Do NOT remove or modify the existing `getSpotlightSuggestions` message handler or `SpotlightMessageClient.getSuggestions()`. They remain as the fallback/original path.
  </action>
  <verify>
Run `npm test` -- all existing tests should pass since no existing methods were modified, only new ones added.

Verify by reading the files:
- `base-data-provider.js` has `getLocalSuggestions()` method
- `search-engine.js` has `getLocalSuggestionsImmediate()` method
- `background.js` has `getLocalSuggestions` and `getAutocompleteSuggestions` handlers
- `message-client.js` has `getLocalSuggestions()` and `getAutocompleteSuggestions()` static methods
  </verify>
  <done>
The two-phase data pipeline exists: local suggestions via `getLocalSuggestions` (fast, ~10-50ms) and autocomplete via `getAutocompleteSuggestions` (slow, ~200-500ms), wired through SearchEngine, background.js, and message-client.js. The original all-in-one path remains intact.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement two-phase progressive rendering in overlay.js and newtab.js</name>
  <files>overlay.js, newtab.js</files>
  <action>
Modify the `handleAsyncSearch()` function in BOTH overlay.js and newtab.js to use the two-phase progressive rendering pattern. The changes are identical in both files (adapted for their respective mode handling).

**In overlay.js:**

Replace the existing `handleAsyncSearch()` function with a two-phase version:

```javascript
// Query generation counter for stale response protection
let searchQueryId = 0;

async function handleAsyncSearch() {
    const query = input.value.trim();
    const queryId = ++searchQueryId;

    if (!query) {
        asyncSuggestions = [];
        updateDisplay();
        return;
    }

    try {
        const mode = spotlightTabMode === SpotlightTabMode.NEW_TAB ? 'new-tab' : 'current-tab';

        // Phase 1: Local results (fast, ~10-50ms)
        const localResults = await SpotlightMessageClient.getLocalSuggestions(query, mode);
        if (queryId !== searchQueryId) return; // Stale query -- discard
        asyncSuggestions = localResults || [];
        updateDisplay();

        // Phase 2: Autocomplete results (slow, ~200-500ms network)
        const autocompleteResults = await SpotlightMessageClient.getAutocompleteSuggestions(query);
        if (queryId !== searchQueryId) return; // Stale query -- discard

        if (autocompleteResults && autocompleteResults.length > 0) {
            // Merge autocomplete with local results using the original all-in-one path
            // for proper deduplication, scoring, and sorting
            const allResults = await SpotlightMessageClient.getSuggestions(query, mode);
            if (queryId !== searchQueryId) return; // Stale query -- discard
            asyncSuggestions = allResults || [];
            updateDisplay();
        }
    } catch (error) {
        Logger.error('[Spotlight] Search error:', error);
        if (queryId === searchQueryId) {
            asyncSuggestions = [];
            updateDisplay();
        }
    }
}
```

**IMPORTANT design decision:** For Phase 2 merging, rather than implementing custom merge/dedup/re-score logic in the UI layer, we call the original `getSuggestions()` (which hits `getSpotlightSuggestions` in background) to get the properly merged, deduped, and scored result set. This is a pragmatic approach that:
- Avoids duplicating BaseDataProvider's dedup/score logic in the UI
- Reuses the tested `getSpotlightSuggestions()` pipeline (which now uses Promise.allSettled from Plan 01)
- By the time Phase 2 fires, autocomplete has already been fetched and cached, so the all-in-one call is fast (local sources + cached autocomplete)
- Stale query guards prevent rendering stale data

The `searchQueryId` variable should be declared in the spotlight function scope (where `asyncSuggestions`, `instantSuggestion`, etc. are declared), NOT inside `handleAsyncSearch`.

**In newtab.js:**

Apply the same pattern. The only difference is mode is always `'current-tab'`:

```javascript
// Query generation counter for stale response protection
let searchQueryId = 0;

async function handleAsyncSearch() {
    const query = input.value.trim();
    const queryId = ++searchQueryId;

    if (!query) {
        asyncSuggestions = [];
        updateDisplay();
        return;
    }

    try {
        // Phase 1: Local results (fast)
        const localResults = await SpotlightMessageClient.getLocalSuggestions(query, 'current-tab');
        if (queryId !== searchQueryId) return;
        asyncSuggestions = localResults || [];
        updateDisplay();

        // Phase 2: Autocomplete results (slow, network)
        const autocompleteResults = await SpotlightMessageClient.getAutocompleteSuggestions(query);
        if (queryId !== searchQueryId) return;

        if (autocompleteResults && autocompleteResults.length > 0) {
            const allResults = await SpotlightMessageClient.getSuggestions(query, 'current-tab');
            if (queryId !== searchQueryId) return;
            asyncSuggestions = allResults || [];
            updateDisplay();
        }
    } catch (error) {
        Logger.error('[NewTab Spotlight] Search error:', error);
        if (queryId === searchQueryId) {
            asyncSuggestions = [];
            updateDisplay();
        }
    }
}
```

Place `searchQueryId` in the same scope as `asyncSuggestions` (inside the main spotlight initialization function, NOT at module level).

**Do NOT modify:**
- `handleInstantInput()` -- instant suggestions stay as-is
- `createInputHandler()` call -- debounce stays at 150ms
- `combineResults()` -- instant + async combination stays as-is
- `updateDisplay()` -- rendering logic stays as-is
- `loadInitialResults()` -- empty query initial load stays as-is
- `sendGetSuggestionsMessage()` -- keep it for loadInitialResults
  </action>
  <verify>
Run `npm test` -- existing tests should pass (overlay and newtab are not unit-tested directly; their logic is tested via integration/E2E tests).

Manual verification: Search for `searchQueryId` in overlay.js and newtab.js to confirm stale query protection exists. Search for `getLocalSuggestions` to confirm Phase 1 calls the local-only path.
  </verify>
  <done>
Both overlay.js and newtab.js use two-phase progressive rendering: Phase 1 shows local results immediately (~10-50ms), Phase 2 appends autocomplete when available (~200-500ms). Stale queries are discarded via query generation counter. Autocomplete is properly merged via the all-in-one path (dedup + score + sort). No UI flickering from stale responses.
  </done>
</task>

</tasks>

<verification>
1. `npm test` passes
2. overlay.js has `searchQueryId` stale query protection and calls `getLocalSuggestions` for Phase 1
3. newtab.js has the same two-phase pattern
4. message-client.js has `getLocalSuggestions()` and `getAutocompleteSuggestions()` methods
5. background.js has corresponding message handlers
6. base-data-provider.js has `getLocalSuggestions()` method
7. The original `getSpotlightSuggestions` path remains intact end-to-end
</verification>

<success_criteria>
- Local results render before autocomplete arrives (two-phase rendering)
- Stale autocomplete responses are discarded (query generation counter)
- Autocomplete results are properly deduped and scored when merged
- No changes to instant suggestion logic, debounce timing, or display rendering
- Original all-in-one search path preserved as fallback
</success_criteria>

<output>
After completion, create `.planning/phases/11-performance/11-02-SUMMARY.md`
</output>
