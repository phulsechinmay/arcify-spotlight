---
phase: 09-fuse.js-matching-engine
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - shared/popular-sites.js
  - shared/data-providers/base-data-provider.js
  - shared/scoring-constants.js
autonomous: true

must_haves:
  truths:
    - "Popular sites matching uses Fuse.js instead of manual start/contains/name matching"
    - "Top sites matching uses Fuse.js instead of manual substring + domain prefix matching"
    - "matchScore from Fuse.js is integrated into calculateRelevanceScore"
    - "The old fuzzyMatch() method is removed from BaseDataProvider"
    - "Title matches rank higher than URL-only matches due to Fuse.js field weights"
  artifacts:
    - path: "shared/popular-sites.js"
      provides: "Fuse.js-based findMatchingDomains function"
      exports: ["findMatchingDomains", "POPULAR_SITES"]
      contains: "FuseSearchService"
    - path: "shared/data-providers/base-data-provider.js"
      provides: "Updated scoring with matchScore, removed fuzzyMatch, Fuse-based top sites"
      contains: "matchScore"
  key_links:
    - from: "shared/popular-sites.js"
      to: "shared/fuse-search-service.js"
      via: "FuseSearchService.search for popular sites matching"
      pattern: "FuseSearchService\\.search"
    - from: "shared/data-providers/base-data-provider.js"
      to: "metadata.matchScore"
      via: "calculateRelevanceScore reads matchScore from result metadata"
      pattern: "metadata\\.matchScore"
---

<objective>
Migrate popular-sites and top-sites matching to Fuse.js, integrate matchScore into the scoring system, and remove the old fuzzyMatch() method.

Purpose: Complete the matching migration for all remaining data sources (popular sites, top sites) and wire Fuse.js match quality into the scoring pipeline so results carry meaningful match scores.
Output: All data sources use Fuse.js. Old fuzzyMatch deleted. matchScore flows into calculateRelevanceScore.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-fuse.js-matching-engine/09-RESEARCH.md
@.planning/phases/09-fuse.js-matching-engine/09-01-SUMMARY.md

Key source files:
@shared/popular-sites.js
@shared/data-providers/base-data-provider.js
@shared/scoring-constants.js
@shared/fuse-search-service.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate popular-sites and top-sites to Fuse.js</name>
  <files>
    shared/popular-sites.js
    shared/data-providers/base-data-provider.js
  </files>
  <action>
    **Part A: Rewrite findMatchingDomains in popular-sites.js**

    1. Add import at top: `import { FuseSearchService } from './fuse-search-service.js';`

    2. Create a module-level prepared data array for Fuse.js searching. This avoids rebuilding it on every call:
       ```js
       // Pre-build searchable array for Fuse.js (built once at module load)
       const _popularSitesList = Object.entries(POPULAR_SITES).map(([domain, displayName]) => ({
           domain,
           displayName,
           domainShort: domain.split('.')[0] // e.g., "github" from "github.com"
       }));
       ```

    3. Replace the entire `findMatchingDomains` function:
       ```js
       export const findMatchingDomains = (partial, maxResults = 10) => {
           if (!partial) return [];

           const fuseResults = FuseSearchService.search(_popularSitesList, partial, {
               keys: [
                   { name: 'displayName', weight: 2 },
                   { name: 'domainShort', weight: 1.5 },
                   { name: 'domain', weight: 1 }
               ],
               threshold: 0.3  // Tighter for popular sites (well-known, short names)
           });

           return fuseResults.slice(0, maxResults).map(result => ({
               domain: result.item.domain,
               displayName: result.item.displayName,
               matchScore: result.matchScore,
               // Keep matchType for backward compatibility with scoring
               matchType: 'fuse'
           }));
       };
       ```

       NOTE: The old function returned matchType values of 'start', 'contains', 'name'. The new function returns 'fuse' for all. This is fine because getFuzzyMatchScore (scoring-constants.js) will be updated in Part C.

    **Part B: Rewrite findMatchingTopSites and getFuzzyDomainMatches in base-data-provider.js**

    1. Add import at top of base-data-provider.js:
       ```js
       import { FuseSearchService } from '../fuse-search-service.js';
       ```

    2. Replace `findMatchingTopSites(topSites, query)` (lines 386-423):
       ```js
       findMatchingTopSites(topSites, query) {
           if (!topSites || topSites.length === 0 || !query) return [];

           const fuseResults = FuseSearchService.search(topSites, query, {
               keys: [
                   { name: 'title', weight: 2 },
                   { name: 'url', weight: 1 }
               ]
           });

           return fuseResults.map(result => result.item);
       }
       ```

       NOTE: The old method returned the original topSites objects (which are already SearchResult objects from getTopSites). The new method does the same via result.item.

    3. Replace `getFuzzyDomainMatches(query)` (lines 426-445):
       ```js
       getFuzzyDomainMatches(query) {
           const matches = findMatchingDomains(query, 5);

           return matches.map(match => {
               return new SearchResult({
                   type: ResultType.TOP_SITE,
                   title: match.displayName,
                   url: `https://${match.domain}`,
                   score: 0, // Will be calculated by calculateRelevanceScore
                   metadata: {
                       fuzzyMatch: true,
                       matchScore: match.matchScore,
                       originalQuery: query
                   }
               });
           });
       }
       ```

       NOTE: The old version used getFuzzyMatchScore(match.matchType, ...) to pre-calculate score. The new version stores matchScore in metadata and lets calculateRelevanceScore handle it (updated in Task 2).

    **Part C: Update scoring-constants.js**

    The `getFuzzyMatchScore` function is no longer needed since Fuse.js provides match quality directly. However, it may still be referenced by tests. For now, keep it but mark it as deprecated with a comment:
    ```js
    // DEPRECATED: Used by old popular-sites matching. Will be removed in Plan 04 test cleanup.
    export const getFuzzyMatchScore = (matchType, domainLength = 0, queryLength = 0) => { ... };
    ```

    No other changes needed to scoring-constants.js in this task.
  </action>
  <verify>
    - `npm run build` succeeds
    - `grep "FuseSearchService" shared/popular-sites.js` confirms Fuse is used
    - `grep "FuseSearchService" shared/data-providers/base-data-provider.js` confirms Fuse is used for top sites
    - The old manual start/contains/name matching loop in popular-sites.js is gone
    - The old domain prefix matching in findMatchingTopSites is gone
  </verify>
  <done>
    Popular sites use Fuse.js with displayName/domain keys and 0.3 threshold. Top sites use Fuse.js with title/url keys. getFuzzyDomainMatches stores matchScore in metadata.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate matchScore into scoring and remove fuzzyMatch</name>
  <files>
    shared/data-providers/base-data-provider.js
  </files>
  <action>
    **Part A: Update calculateRelevanceScore to use matchScore**

    Modify `calculateRelevanceScore(result, query)` in base-data-provider.js (lines 353-383):

    The current method has a special case for `result.metadata?.fuzzyMatch` that returns `result.score` directly. Update it to integrate matchScore from Fuse.js:

    ```js
    calculateRelevanceScore(result, query) {
        // If this result has a Fuse.js matchScore, use it to boost the base score
        // matchScore is 0-1 where 1 = perfect match
        const matchScore = result.metadata?.matchScore;

        let baseScore = 0;

        switch (result.type) {
            case ResultType.SEARCH_QUERY: baseScore = BASE_SCORES.SEARCH_QUERY; break;
            case ResultType.URL_SUGGESTION: baseScore = BASE_SCORES.URL_SUGGESTION; break;
            case ResultType.OPEN_TAB: baseScore = BASE_SCORES.OPEN_TAB; break;
            case ResultType.PINNED_TAB: baseScore = BASE_SCORES.PINNED_TAB; break;
            case ResultType.BOOKMARK: baseScore = BASE_SCORES.BOOKMARK; break;
            case ResultType.HISTORY: baseScore = BASE_SCORES.HISTORY; break;
            case ResultType.TOP_SITE: baseScore = BASE_SCORES.TOP_SITE; break;
            case ResultType.AUTOCOMPLETE_SUGGESTION: baseScore = BASE_SCORES.AUTOCOMPLETE_SUGGESTION; break;
        }

        // If matchScore is available (from Fuse.js), use it as a bonus
        // Scale matchScore (0-1) to a bonus range (0-25) to influence ordering
        // within the same result type while preserving type hierarchy
        if (matchScore != null && matchScore > 0) {
            baseScore += matchScore * 25;
            return Math.max(0, baseScore);
        }

        // Fallback: string matching bonuses for results without Fuse.js matchScore
        // (e.g., autocomplete suggestions, URL suggestions)
        const queryLower = query.toLowerCase();
        const titleLower = result.title.toLowerCase();
        const urlLower = result.url.toLowerCase();

        if (titleLower === queryLower) baseScore += SCORE_BONUSES.EXACT_TITLE_MATCH;
        else if (titleLower.startsWith(queryLower)) baseScore += SCORE_BONUSES.TITLE_STARTS_WITH;
        else if (titleLower.includes(queryLower)) baseScore += SCORE_BONUSES.TITLE_CONTAINS;

        if (urlLower.includes(queryLower)) baseScore += SCORE_BONUSES.URL_CONTAINS;

        return Math.max(0, baseScore);
    }
    ```

    Key design decisions:
    - matchScore * 25 gives a bonus range of 0-25 points. This means a perfect title match (matchScore ~0.95) adds ~24 points, which is comparable to the old EXACT_TITLE_MATCH bonus (20) + URL_CONTAINS (5) = 25. This preserves relative ordering behavior.
    - When matchScore is present, the string matching bonuses are skipped to avoid double-counting (Fuse.js already accounts for title vs URL matching via field weights).
    - The type hierarchy (OPEN_TAB=90 > BOOKMARK=80 > HISTORY=70) is preserved. matchScore only adjusts within-type ordering.
    - Results without matchScore (autocomplete, URL suggestions, search queries) still use the old string matching bonuses.

    **Part B: Remove fuzzyMatch method from BaseDataProvider**

    Delete the `fuzzyMatch(query, text)` method (lines 454-474) from base-data-provider.js. It is no longer called anywhere:
    - background-data-provider.js: replaced by Fuse.js (Plans 01 and 02)
    - base-data-provider.js: findMatchingTopSites and getFuzzyDomainMatches replaced (Task 1 of this plan)

    Also remove the import of `getFuzzyMatchScore` from scoring-constants.js in the import statement at the top of base-data-provider.js (line 5), since it's no longer used:
    ```js
    // Before:
    import { BASE_SCORES, SCORE_BONUSES, getFuzzyMatchScore } from '../scoring-constants.js';
    // After:
    import { BASE_SCORES, SCORE_BONUSES } from '../scoring-constants.js';
    ```

    **Part C: Remove the fuzzyMatch metadata passthrough**

    In the old calculateRelevanceScore, there was this early return:
    ```js
    if (result.metadata?.fuzzyMatch) {
        return result.score;
    }
    ```

    This is already handled by the new matchScore-based logic. The `metadata.fuzzyMatch` flag is still set by getFuzzyDomainMatches for deduplication priority purposes (in getResultPriority), so keep it in the metadata but remove the early return from scoring (which is already done in Part A's rewrite).

    IMPORTANT: Do NOT modify the getResultPriority method. It uses `metadata?.fuzzyMatch` for deduplication priority, which is still valid.
  </action>
  <verify>
    - `npm run build` succeeds
    - `npm test` -- some existing tests will likely FAIL because:
      1. fuzzy-matching.test.js tests `provider.fuzzyMatch()` which is now deleted
      2. scoring.test.js tests the old `fuzzyMatch passthrough` behavior
      These failures are expected and will be fixed in Plan 04 (test updates).
    - `grep "fuzzyMatch" shared/data-providers/base-data-provider.js` returns NO matches (method deleted)
    - `grep "matchScore" shared/data-providers/base-data-provider.js` returns matches in calculateRelevanceScore
  </verify>
  <done>
    matchScore integrated into calculateRelevanceScore with 0-25 point bonus range. fuzzyMatch() method removed from BaseDataProvider. Old fuzzyMatch passthrough in scoring removed. Type hierarchy preserved.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `npm run build` succeeds
2. `grep "fuzzyMatch" shared/data-providers/base-data-provider.js` returns NO results (method removed)
3. `grep "FuseSearchService" shared/popular-sites.js shared/data-providers/base-data-provider.js` shows Fuse.js used in both
4. `grep "matchScore" shared/data-providers/base-data-provider.js` shows matchScore integration in calculateRelevanceScore
5. Some tests will fail (expected -- fixed in Plan 04)
</verification>

<success_criteria>
- Popular sites use Fuse.js for matching (not manual start/contains/name checks)
- Top sites use Fuse.js for matching (not manual substring/domain prefix)
- calculateRelevanceScore uses matchScore (0-1) from Fuse.js as a bonus (0-25 points)
- Type hierarchy preserved (open-tab > bookmark > history > top-site)
- fuzzyMatch() method deleted from BaseDataProvider
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/09-fuse.js-matching-engine/09-03-SUMMARY.md`
</output>
