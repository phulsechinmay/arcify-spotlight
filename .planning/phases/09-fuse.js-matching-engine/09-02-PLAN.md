---
phase: 09-fuse.js-matching-engine
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - bookmark-utils.js
  - shared/data-providers/background-data-provider.js
  - background.js
autonomous: true

must_haves:
  truths:
    - "Bookmark search uses Fuse.js fuzzy matching instead of Chrome's substring-only bookmarks.search()"
    - "Typing 'ghub' finds a bookmark titled 'GitHub' (fuzzy match that Chrome substring search would miss)"
    - "Bookmarks are cached to avoid fetching all bookmarks on every keystroke"
    - "Bookmark cache is invalidated when bookmarks change (created, removed, moved, changed)"
    - "History results from chrome.history.search() are re-scored with Fuse.js match quality"
    - "History results include a matchScore property (0-1)"
  artifacts:
    - path: "bookmark-utils.js"
      provides: "getAllBookmarks method and bookmark cache"
      contains: "getAllBookmarks"
    - path: "shared/data-providers/background-data-provider.js"
      provides: "Bookmark and history data with Fuse.js matching"
      contains: "FuseSearchService"
    - path: "background.js"
      provides: "Bookmark cache invalidation on change events"
      contains: "invalidateBookmarkCache"
  key_links:
    - from: "shared/data-providers/background-data-provider.js"
      to: "bookmark-utils.js"
      via: "BookmarkUtils.getAllBookmarks() for cached bookmark fetching"
      pattern: "BookmarkUtils\\.getAllBookmarks"
    - from: "background.js"
      to: "bookmark-utils.js"
      via: "Cache invalidation on bookmark change events"
      pattern: "invalidateBookmarkCache"
    - from: "shared/data-providers/background-data-provider.js"
      to: "shared/fuse-search-service.js"
      via: "FuseSearchService.search for bookmark and history filtering"
      pattern: "FuseSearchService\\.search"
---

<objective>
Migrate bookmark and history data sources to Fuse.js matching. Bookmarks require the most significant change: replacing Chrome's bookmarks.search() substring matching with a cached full-bookmark-list + Fuse.js filter approach. History keeps Chrome's history.search() for retrieval but adds Fuse.js re-scoring for match quality.

Purpose: Enable fuzzy matching for bookmarks (the biggest gap -- Chrome's substring search misses "ghub"->GitHub) and add match quality scores to history results.
Output: Bookmarks use cached fetch + Fuse.js filter with cache invalidation. History results include matchScore from Fuse.js.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-fuse.js-matching-engine/09-RESEARCH.md
@.planning/phases/09-fuse.js-matching-engine/09-01-SUMMARY.md

Key source files:
@bookmark-utils.js
@shared/data-providers/background-data-provider.js
@background.js
@shared/fuse-search-service.js
@shared/data-providers/base-data-provider.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add bookmark cache and migrate bookmarks to Fuse.js</name>
  <files>
    bookmark-utils.js
    shared/data-providers/background-data-provider.js
    background.js
  </files>
  <action>
    **Part A: Add getAllBookmarks() and bookmark cache to BookmarkUtils (bookmark-utils.js)**

    1. Add a cached bookmark list to BookmarkUtils. Add these properties at the top of the BookmarkUtils object:
       ```js
       _bookmarkCache: null,
       _bookmarkCacheValid: false,
       ```

    2. Add `invalidateBookmarkCache()` method:
       ```js
       invalidateBookmarkCache() {
           this._bookmarkCache = null;
           this._bookmarkCacheValid = false;
           Logger.log('[BookmarkUtils] Bookmark cache invalidated');
       },
       ```

    3. Add `getAllBookmarks()` method that returns cached bookmarks or fetches them:
       ```js
       async getAllBookmarks() {
           if (this._bookmarkCacheValid && this._bookmarkCache) {
               return this._bookmarkCache;
           }

           try {
               // Fetch entire bookmark tree and flatten to bookmark nodes with URLs
               const tree = await chrome.bookmarks.getTree();
               const allBookmarks = [];

               const traverse = (nodes) => {
                   for (const node of nodes) {
                       if (node.url) {
                           allBookmarks.push({
                               id: node.id,
                               title: node.title || '',
                               url: node.url,
                               parentId: node.parentId
                           });
                       }
                       if (node.children) {
                           traverse(node.children);
                       }
                   }
               };

               traverse(tree);

               this._bookmarkCache = allBookmarks;
               this._bookmarkCacheValid = true;
               Logger.log('[BookmarkUtils] Bookmark cache built:', allBookmarks.length, 'bookmarks');
               return allBookmarks;
           } catch (error) {
               Logger.error('[BookmarkUtils] Error fetching all bookmarks:', error);
               return [];
           }
       },
       ```

    **Part B: Wire bookmark cache invalidation into background.js**

    In background.js, the existing bookmark change listeners (lines 19-48) already call `arcifyProvider.invalidateCache()`. Add `BookmarkUtils.invalidateBookmarkCache()` calls to the same listeners:

    1. Add import at top of background.js:
       ```js
       import { BookmarkUtils } from './bookmark-utils.js';
       ```
       (Check if it's already imported -- it may be imported indirectly through BackgroundDataProvider.)

    2. In each of the four bookmark event listeners (onCreated, onRemoved, onMoved, onChanged), add:
       ```js
       BookmarkUtils.invalidateBookmarkCache();
       ```

    3. In the onImportEnded listener, also add `BookmarkUtils.invalidateBookmarkCache()` alongside the existing arcifyProvider invalidation.

    **Part C: Migrate getBookmarksData to Fuse.js in background-data-provider.js**

    Replace the current `getBookmarksData(query)` method:

    Current (line 98-100):
    ```js
    async getBookmarksData(query) {
        return await BookmarkUtils.getBookmarksData(query);
    }
    ```

    New implementation:
    ```js
    async getBookmarksData(query) {
        try {
            // Get all bookmarks from cache (fast after first call)
            const allBookmarks = await BookmarkUtils.getAllBookmarks();

            // Exclude Arcify folder bookmarks from regular search
            let arcifyFolderId = null;
            try {
                const arcifyFolder = await BookmarkUtils.findArcifyFolder();
                if (arcifyFolder) {
                    arcifyFolderId = arcifyFolder.id;
                }
            } catch (error) {
                // Ignore if Arcify folder doesn't exist
            }

            const searchableBookmarks = arcifyFolderId
                ? allBookmarks.filter(b => !BookmarkUtils.isUnderArcifyFolder(b, arcifyFolderId))
                : allBookmarks;

            // Use Fuse.js for fuzzy matching (replaces Chrome's substring-only search)
            const fuseResults = FuseSearchService.search(searchableBookmarks, query, {
                keys: [
                    { name: 'title', weight: 2 },
                    { name: 'url', weight: 1 }
                ]
            });

            // Map back to the expected bookmark format with matchScore
            return fuseResults.map(result => ({
                ...result.item,
                _matchScore: result.matchScore
            }));
        } catch (error) {
            Logger.error('[BackgroundDataProvider] Error getting bookmarks with Fuse:', error);
            return [];
        }
    }
    ```

    Also update getBookmarkSuggestions in base-data-provider.js to propagate _matchScore into SearchResult metadata:
    In the `bookmarksData.map(bookmark => new SearchResult({...}))` section, add matchScore:
    ```js
    metadata: { bookmarkId: bookmark.id, matchScore: bookmark._matchScore || null }
    ```

    IMPORTANT: The old `BookmarkUtils.getBookmarksData(query)` method in bookmark-utils.js should NOT be deleted yet -- it may be used elsewhere and will be cleaned up in Plan 03. The background-data-provider just stops calling it.
  </action>
  <verify>
    - `npm run build` succeeds
    - `npm test` passes
    - `grep "FuseSearchService" shared/data-providers/background-data-provider.js` confirms Fuse is used in getBookmarksData
    - `grep "getAllBookmarks" bookmark-utils.js` confirms the new method exists
    - `grep "invalidateBookmarkCache" background.js` confirms cache invalidation is wired
  </verify>
  <done>
    Bookmarks use Fuse.js fuzzy matching via cached full bookmark list. Cache invalidates on bookmark change events. Arcify folder bookmarks are excluded. Bookmark results include _matchScore.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate history to Fuse.js re-scoring</name>
  <files>
    shared/data-providers/background-data-provider.js
    shared/data-providers/base-data-provider.js
  </files>
  <action>
    **Strategy:** Keep chrome.history.search() for data retrieval (it handles recency natively and returns relevant history items). Apply Fuse.js as a re-scoring layer to add match quality scores.

    **Modify getHistoryData(query) in background-data-provider.js:**

    Current (lines 109-121):
    ```js
    async getHistoryData(query) {
        try {
            const historyItems = await chrome.history.search({
                text: query,
                maxResults: 10,
                startTime: Date.now() - (7 * 24 * 60 * 60 * 1000)
            });
            return historyItems;
        } catch (error) {
            Logger.error('[BackgroundDataProvider] Error getting history:', error);
            return [];
        }
    }
    ```

    New implementation:
    ```js
    async getHistoryData(query) {
        try {
            // Use Chrome's history search for retrieval (respects recency natively)
            const historyItems = await chrome.history.search({
                text: query,
                maxResults: 20, // Fetch more to allow Fuse.js to re-rank and filter
                startTime: Date.now() - (7 * 24 * 60 * 60 * 1000)
            });

            if (!historyItems || historyItems.length === 0) return [];

            // Apply Fuse.js scoring to Chrome's results for match quality
            const fuseResults = FuseSearchService.search(historyItems, query, {
                keys: [
                    { name: 'title', weight: 2 },
                    { name: 'url', weight: 1 }
                ]
            });

            // Map back with matchScore attached
            // Items that Chrome returned but Fuse.js didn't match get filtered out
            // (they were probably very loose substring matches)
            return fuseResults.slice(0, 10).map(result => ({
                ...result.item,
                _matchScore: result.matchScore
            }));
        } catch (error) {
            Logger.error('[BackgroundDataProvider] Error getting history:', error);
            return [];
        }
    }
    ```

    **Update getHistorySuggestions in base-data-provider.js** to propagate _matchScore:

    In the `historyData.map(item => new SearchResult({...}))` section (lines 262-270), add matchScore to metadata:
    ```js
    metadata: {
        visitCount: item.visitCount,
        lastVisitTime: item.lastVisitTime,
        matchScore: item._matchScore || null
    }
    ```

    NOTE: The increased maxResults (10 -> 20) compensates for Fuse.js potentially filtering out some loose Chrome matches. We then slice back to 10 after Fuse scoring.
  </action>
  <verify>
    - `npm run build` succeeds
    - `npm test` passes
    - `grep "FuseSearchService" shared/data-providers/background-data-provider.js` shows Fuse used in both getBookmarksData and getHistoryData
  </verify>
  <done>
    History results are fetched via chrome.history.search(), re-scored with Fuse.js match quality, and include _matchScore in metadata. Loose Chrome substring matches are filtered out by Fuse.js threshold.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `npm run build` succeeds
2. `npm test` passes
3. All data source methods in background-data-provider.js that previously used fuzzyMatch now use FuseSearchService (getOpenTabsData from Plan 01, getPinnedTabsData from Plan 01, getBookmarksData, getHistoryData)
4. BookmarkUtils has getAllBookmarks() with cache
5. background.js invalidates bookmark cache on change events
6. SearchResult metadata includes matchScore for tabs, pinned tabs, bookmarks, and history
</verification>

<success_criteria>
- Bookmarks use Fuse.js fuzzy matching (not Chrome substring search)
- "ghub" query would match a bookmark titled "GitHub" (fuzzy match)
- Bookmark cache exists, populated on first search, invalidated on change events
- History keeps Chrome retrieval but adds Fuse.js match quality scoring
- All results carry matchScore in metadata (0-1, 1=perfect)
- Build succeeds, tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-fuse.js-matching-engine/09-02-SUMMARY.md`
</output>
