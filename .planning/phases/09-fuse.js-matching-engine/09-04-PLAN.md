---
phase: 09-fuse.js-matching-engine
plan: 04
type: execute
wave: 3
depends_on: ["09-02", "09-03"]
files_modified:
  - test/unit/fuzzy-matching.test.js
  - test/unit/scoring.test.js
autonomous: true

must_haves:
  truths:
    - "All unit tests pass after Fuse.js migration"
    - "Fuzzy matching tests verify Fuse.js behavior (matchScore, thresholds, field weights)"
    - "Scoring tests verify matchScore integration into calculateRelevanceScore"
    - "Key abbreviation patterns still work: ghub->GitHub, yt->YouTube, gml->Gmail"
    - "Short query false positive prevention is tested (2-3 char queries)"
  artifacts:
    - path: "test/unit/fuzzy-matching.test.js"
      provides: "Tests for FuseSearchService and Fuse-based findMatchingDomains"
      contains: "FuseSearchService"
    - path: "test/unit/scoring.test.js"
      provides: "Tests for matchScore integration in calculateRelevanceScore"
      contains: "matchScore"
  key_links:
    - from: "test/unit/fuzzy-matching.test.js"
      to: "shared/fuse-search-service.js"
      via: "import and test of FuseSearchService.search"
      pattern: "FuseSearchService"
    - from: "test/unit/scoring.test.js"
      to: "shared/data-providers/base-data-provider.js"
      via: "test of calculateRelevanceScore with matchScore in metadata"
      pattern: "matchScore"
---

<objective>
Update all unit tests to reflect the Fuse.js migration. The old fuzzyMatch tests must be rewritten to test FuseSearchService behavior, and scoring tests must be updated for the new matchScore integration.

Purpose: Ensure test suite passes after the Fuse.js migration, providing regression safety for the remaining v2.0 phases.
Output: All tests green. Key matching patterns verified with Fuse.js. Scoring tests updated.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-fuse.js-matching-engine/09-RESEARCH.md
@.planning/phases/09-fuse.js-matching-engine/09-01-SUMMARY.md
@.planning/phases/09-fuse.js-matching-engine/09-02-SUMMARY.md
@.planning/phases/09-fuse.js-matching-engine/09-03-SUMMARY.md

Key source files:
@test/unit/fuzzy-matching.test.js
@test/unit/scoring.test.js
@shared/fuse-search-service.js
@shared/popular-sites.js
@shared/data-providers/base-data-provider.js
@shared/scoring-constants.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite fuzzy-matching tests for Fuse.js</name>
  <files>test/unit/fuzzy-matching.test.js</files>
  <action>
    The current test file tests two things:
    1. `BaseDataProvider.fuzzyMatch` (now deleted)
    2. `findMatchingDomains` (now Fuse.js-based with different return structure)

    Rewrite the entire file. The new test file should cover:

    **Section 1: FuseSearchService.search**

    Import FuseSearchService from shared/fuse-search-service.js. Test:

    1. **Basic matching with score:**
       - Search items with title/url keys, verify results have `item` and `matchScore` properties
       - Verify matchScore is between 0 and 1
       - Verify matchScore is close to 1 for exact matches

    2. **Key abbreviation patterns that MUST work** (from research -- Pitfall 5):
       Test each against an array of items with those titles:
       - "ghub" matches item with title "GitHub" (matchScore > 0)
       - "gml" matches item with title "Gmail" (matchScore > 0)
       - "goog" matches item with title "Google" (matchScore > 0)
       - "fb" matches item with title "Facebook" (matchScore > 0)
       - "yt" matches item with title "YouTube" (matchScore > 0)
       - "rd" matches item with title "Reddit" (matchScore > 0)
       - "tw" matches item with title "Twitter" (matchScore > 0)

       NOTE: Some of these may NOT match with Fuse.js at threshold 0.4. For example, "fb" for "Facebook" is a character-order match that Fuse.js's Bitap algorithm may not support. If tests fail, document which patterns Fuse.js handles differently and adjust the test expectations accordingly. The priority is accuracy (no false positives) over matching every old abbreviation pattern.

       Use this test structure:
       ```js
       const testItems = [
           { title: 'GitHub', url: 'https://github.com' },
           { title: 'Gmail', url: 'https://mail.google.com' },
           { title: 'Google', url: 'https://google.com' },
           { title: 'Facebook', url: 'https://facebook.com' },
           { title: 'YouTube', url: 'https://youtube.com' },
           { title: 'Reddit', url: 'https://reddit.com' },
           { title: 'Twitter', url: 'https://twitter.com' },
       ];
       ```

    3. **Title weight > URL weight (MATCH-02):**
       - Create two items: one with query in title only, one with query in URL only
       - Verify title-match item has higher matchScore than URL-match item
       - Example: query "github", item A = {title: "GitHub Dashboard", url: "https://example.com"}, item B = {title: "My Page", url: "https://github.com"}
       - Assert: result[0].item.title contains "GitHub" (title match ranks first)

    4. **Short query false positive prevention (MATCH-03):**
       - Search with 2-3 char queries against items where the query should NOT match
       - Example: query "ab", items [{title: "xyz123", url: "https://xyz.com"}]
       - Verify no results returned (or very low matchScore)
       - Also test that minMatchCharLength: 2 prevents single-char clutter

    5. **Empty/null inputs:**
       - FuseSearchService.search([], 'query') returns []
       - FuseSearchService.search(items, '') returns []
       - FuseSearchService.search(null, 'query') returns []

    6. **Score inversion correctness:**
       - Search for an exact match and verify matchScore is close to 1.0 (not close to 0.0)
       - This catches Pitfall 1 (score direction)

    **Section 2: findMatchingDomains (Fuse.js version)**

    Import findMatchingDomains from shared/popular-sites.js. Test:

    1. **Basic matching:**
       - "git" finds github.com and gitlab.com
       - "squaresp" finds squarespace.com
       - "face" finds facebook.com

    2. **Return structure:**
       - Results have domain, displayName, matchScore, matchType properties
       - matchType is 'fuse' for all results
       - matchScore is a number between 0 and 1

    3. **maxResults:**
       - Respects maxResults parameter (e.g., maxResults=3 returns at most 3)

    4. **No matches:**
       - "zzzzxxxxxqqqqq" returns []

    5. **Empty input:**
       - Empty string returns [] (changed from old behavior which returned all)

    IMPORTANT: Run `npm test` after writing the test file. If any tests fail because Fuse.js doesn't match certain abbreviation patterns (like "fb" -> "Facebook"), adjust the test to reflect Fuse.js's actual behavior. Document the behavioral difference in a comment. The goal is a green test suite that accurately tests Fuse.js behavior, not forcing Fuse.js to match the old fuzzyMatch behavior exactly.
  </action>
  <verify>
    - `npm test -- test/unit/fuzzy-matching.test.js` passes
    - Test file imports FuseSearchService (not BaseDataProvider.fuzzyMatch)
    - Key patterns tested: title > URL weighting, short query prevention, score inversion
  </verify>
  <done>
    fuzzy-matching.test.js fully rewritten for Fuse.js. Tests cover: basic matching with scores, abbreviation patterns, title>URL weighting, short query false positives, edge cases, score inversion. findMatchingDomains tests updated for new return structure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update scoring tests for matchScore integration</name>
  <files>test/unit/scoring.test.js</files>
  <action>
    The current test file tests:
    1. getAutocompleteScore (unchanged -- keep as-is)
    2. getFuzzyMatchScore (deprecated -- remove or update)
    3. BaseDataProvider.calculateRelevanceScore (updated to use matchScore)
    4. BASE_SCORES constants (unchanged -- keep as-is)
    5. SCORE_BONUSES constants (unchanged -- keep as-is)

    **Section 1: Keep getAutocompleteScore tests as-is** (lines 10-36 in current file)

    **Section 2: Update or remove getFuzzyMatchScore tests** (lines 38-88)

    If getFuzzyMatchScore is still exported (marked deprecated), keep the tests but add a note:
    ```js
    describe('getFuzzyMatchScore (DEPRECATED - will be removed)', () => { ... })
    ```

    If it was removed from scoring-constants.js, delete these tests entirely.

    **Section 3: Rewrite calculateRelevanceScore tests** (lines 90-247)

    The key changes:
    - The "fuzzy match passthrough" tests (lines 186-224) need to be completely rewritten
    - Add new "matchScore integration" tests
    - Keep the base score and string matching bonus tests (they cover the fallback path for results without matchScore)

    New/modified test sections:

    a) **Base scores by result type** -- keep as-is (lines 97-127). These still work because calculateRelevanceScore still assigns base scores by type.

    b) **Title match bonuses** -- keep as-is (lines 129-147). These cover the fallback path when matchScore is not present.

    c) **URL match bonuses** -- keep as-is (lines 149-161).

    d) **Combined bonuses** -- keep as-is (lines 163-184). Fallback path.

    e) **REPLACE "fuzzy match passthrough"** with "matchScore integration" tests:

    ```js
    describe('matchScore integration', () => {
        it('adds matchScore bonus when matchScore is present in metadata', () => {
            const result = {
                type: 'open-tab',
                title: 'GitHub',
                url: 'https://github.com',
                metadata: { matchScore: 0.9 }
            };
            const score = provider.calculateRelevanceScore(result, 'github');
            // baseScore (90) + matchScore bonus (0.9 * 25 = 22.5) = 112.5
            expect(score).toBe(BASE_SCORES.OPEN_TAB + 0.9 * 25);
        });

        it('perfect matchScore gives maximum bonus', () => {
            const result = {
                type: 'bookmark',
                title: 'Test',
                url: 'https://test.com',
                metadata: { matchScore: 1.0 }
            };
            const score = provider.calculateRelevanceScore(result, 'test');
            expect(score).toBe(BASE_SCORES.BOOKMARK + 25);
        });

        it('low matchScore gives small bonus', () => {
            const result = {
                type: 'history',
                title: 'Test',
                url: 'https://test.com',
                metadata: { matchScore: 0.2 }
            };
            const score = provider.calculateRelevanceScore(result, 'test');
            expect(score).toBe(BASE_SCORES.HISTORY + 0.2 * 25);
        });

        it('skips string matching bonuses when matchScore is present', () => {
            // Even though title exactly matches query, matchScore path is used
            const result = {
                type: 'history',
                title: 'github',
                url: 'https://github.com',
                metadata: { matchScore: 0.95 }
            };
            const score = provider.calculateRelevanceScore(result, 'github');
            // Should use matchScore bonus (23.75), NOT string bonuses (20+5=25)
            expect(score).toBe(BASE_SCORES.HISTORY + 0.95 * 25);
        });

        it('falls back to string matching when matchScore is null', () => {
            const result = {
                type: 'history',
                title: 'github',
                url: 'https://github.com',
                metadata: { matchScore: null }
            };
            const score = provider.calculateRelevanceScore(result, 'github');
            // Should use string matching: EXACT_TITLE_MATCH (20) + URL_CONTAINS (5)
            expect(score).toBe(BASE_SCORES.HISTORY + SCORE_BONUSES.EXACT_TITLE_MATCH + SCORE_BONUSES.URL_CONTAINS);
        });

        it('falls back to string matching when metadata has no matchScore', () => {
            const result = {
                type: 'history',
                title: 'github',
                url: 'https://github.com',
                metadata: {}
            };
            const score = provider.calculateRelevanceScore(result, 'github');
            expect(score).toBe(BASE_SCORES.HISTORY + SCORE_BONUSES.EXACT_TITLE_MATCH + SCORE_BONUSES.URL_CONTAINS);
        });

        it('preserves type hierarchy even with matchScore', () => {
            const tabResult = {
                type: 'open-tab',
                title: 'Test',
                url: 'https://test.com',
                metadata: { matchScore: 0.5 }
            };
            const bookmarkResult = {
                type: 'bookmark',
                title: 'Test',
                url: 'https://test.com',
                metadata: { matchScore: 0.5 }
            };
            const tabScore = provider.calculateRelevanceScore(tabResult, 'test');
            const bookmarkScore = provider.calculateRelevanceScore(bookmarkResult, 'test');
            expect(tabScore).toBeGreaterThan(bookmarkScore);
        });

        it('does not add bonus when matchScore is 0', () => {
            const result = {
                type: 'history',
                title: 'Test',
                url: 'https://test.com',
                metadata: { matchScore: 0 }
            };
            const score = provider.calculateRelevanceScore(result, 'nomatch');
            // matchScore is 0, so falls through to string matching path
            expect(score).toBe(BASE_SCORES.HISTORY);
        });
    });
    ```

    f) **Case insensitivity** -- keep as-is (lines 226-237). Fallback path.

    g) **Minimum score enforcement** -- keep as-is (lines 239-246).

    **Section 4: Keep BASE_SCORES and SCORE_BONUSES constant tests as-is.**

    After writing, run `npm test` to verify all tests pass. If any fail, debug and fix.
  </action>
  <verify>
    - `npm test -- test/unit/scoring.test.js` passes
    - Test file has "matchScore integration" describe block
    - Tests verify: matchScore bonus calculation, type hierarchy preservation, fallback to string matching
    - All previously passing tests that are still relevant continue to pass
  </verify>
  <done>
    scoring.test.js updated for matchScore integration. Tests cover: matchScore bonus (0-25 points), perfect/low/zero matchScore, type hierarchy preservation, fallback to string matching when matchScore absent, case insensitivity on fallback path.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `npm test` ALL tests pass (the full suite, not just the two files)
2. `npm run build` succeeds
3. No references to `provider.fuzzyMatch` in test files
4. Tests verify MATCH-02 (title > URL), MATCH-03 (short query protection), MATCH-04 (score 0-1)
</verification>

<success_criteria>
- `npm test` exits with 0 (all tests pass)
- fuzzy-matching.test.js tests FuseSearchService behavior, not old fuzzyMatch
- scoring.test.js tests matchScore integration, not old fuzzyMatch passthrough
- Key abbreviation patterns documented (which work, which don't with Fuse.js)
- Title > URL weighting tested
- Short query false positive prevention tested
- Score inversion (1=best) tested
</success_criteria>

<output>
After completion, create `.planning/phases/09-fuse.js-matching-engine/09-04-SUMMARY.md`
</output>
