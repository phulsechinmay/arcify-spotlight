---
phase: 12-regression-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - test/integration/regression.test.js
autonomous: true

must_haves:
  truths:
    - "All 326 existing tests pass with zero failures"
    - "Same URL from two data sources (e.g., history + open tabs) produces exactly one result after full pipeline"
    - "getLocalSuggestions() also deduplicates correctly (Phase 11 progressive rendering path)"
    - "Arcify-enriched tabs carry isArcify metadata and produce correct wording through formatResult()"
    - "Action routing contracts are confirmed: tab switch, URL navigation, bookmark opening"
  artifacts:
    - path: "test/integration/regression.test.js"
      provides: "Integration-level regression tests for REG-02 behavioral contracts"
      min_lines: 80
  key_links:
    - from: "test/integration/regression.test.js"
      to: "shared/data-providers/base-data-provider.js"
      via: "TestDataProvider subclass calling real getSpotlightSuggestions/getLocalSuggestions"
      pattern: "getSpotlightSuggestions|getLocalSuggestions"
    - from: "test/integration/regression.test.js"
      to: "shared/data-providers/base-data-provider.js enrichWithArcifyInfo"
      via: "Mock arcifyProvider injected, real enrichment pipeline runs"
      pattern: "arcifyProvider"
---

<objective>
Validate that all existing functionality works correctly after the full v2.0 migration (Phases 9-11).

Purpose: This is the final phase of v2.0 — confirming that Fuse.js matching, weighted scoring, parallel fetching, and progressive rendering did not break any existing behavior. REG-01 (all tests pass) and REG-02 (deduplication, Arcify enrichment, action routing unchanged) must both be satisfied.

Output: Verified test suite run (326 tests, 0 failures) + new `test/integration/regression.test.js` covering the integration-level gaps identified in research.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-regression-validation/12-RESEARCH.md
@shared/data-providers/base-data-provider.js
@shared/search-types.js
@shared/search-engine.js
@test/unit/arcify-enrichment.test.js
@test/unit/deduplication.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify REG-01 — Full test suite passes</name>
  <files>(no files modified — read-only verification)</files>
  <action>
Run the full test suite with verbose output:
```bash
npx vitest run --reporter=verbose
```

Verify:
1. All 14 test files pass
2. All 326 tests pass with zero failures
3. No skipped tests (unless previously known and documented)

If any test fails, diagnose and fix it before proceeding to Task 2. The fix should be minimal — this is a regression phase, not a feature phase.

This task satisfies REG-01.
  </action>
  <verify>
`npx vitest run` output shows "326 passed (326)" and "14 passed (14)" with zero failures.
  </verify>
  <done>All 326 existing tests pass with zero failures. REG-01 is satisfied.</done>
</task>

<task type="auto">
  <name>Task 2: Write integration regression tests for REG-02 behavioral contracts</name>
  <files>test/integration/regression.test.js</files>
  <action>
Create `test/integration/regression.test.js` with integration-level tests that exercise the REAL business logic pipeline (dedup + enrichment + scoring) through `BaseDataProvider`.

**Architecture:** Create a `TestDataProvider` class that extends `BaseDataProvider` and overrides ONLY the abstract data fetcher methods (getOpenTabsData, getBookmarksData, getHistoryData, getTopSitesData, getAutocompleteData, getPinnedTabsData, getRecentTabsData). The real `getSpotlightSuggestions()`, `getLocalSuggestions()`, `deduplicateResults()`, `enrichWithArcifyInfo()`, `scoreAndSortResults()`, and `calculateRelevanceScore()` all run as production code.

**Test sections (3 describe blocks):**

**1. "REG-02: Deduplication across data sources" (~5-6 tests)**
- Same URL from history + open tabs → exactly 1 result, type is `open-tab` (higher priority wins)
- Same URL from bookmark + history → exactly 1 result, type is `bookmark`
- URL normalization in pipeline: `https://www.example.com/` from tabs + `http://example.com` from history → 1 result
- Different URLs from different sources → all preserved (no false dedup)
- Test via `getLocalSuggestions()` path too: same URL from tabs + bookmarks → 1 result (confirms Phase 11 progressive path deduplicates)

**2. "REG-02: Arcify enrichment in pipeline" (~3 tests)**
- Setup: inject mock `arcifyProvider` on the TestDataProvider instance (same pattern as arcify-enrichment.test.js — pre-set `provider.arcifyProvider` with mock `ensureCacheBuilt`, `hasData`, `getSpaceForUrl`)
- Open tab that matches Arcify URL → result has `isArcify: true`, `spaceName`, `spaceColor` in metadata
- Open tab that does NOT match Arcify → result has no `isArcify` metadata
- Enrichment happens AFTER dedup: duplicate URL from tabs + history, only the surviving result (open-tab) gets enriched

**3. "REG-02: Action routing contracts" (~3 tests)**
- These are CONTRACT tests confirming the API shape hasn't changed — NOT duplicating the 22 existing action-routing tests
- Instantiate `SearchEngine` with a mock data provider (`isBackgroundProvider: true`)
- Open tab result → `chrome.tabs.update` called with tabId, `chrome.windows.update` called with windowId
- URL suggestion → `chrome.tabs.create` called with URL
- Bookmark result → `chrome.tabs.create` called with URL
- Use minimal assertions — just confirm the contract (which Chrome API is called), not edge cases

**Important patterns:**
- Import from `../../shared/data-providers/base-data-provider.js`, `../../shared/search-types.js`, `../../shared/search-engine.js`
- Use `vi.fn()` for Chrome API mocks (the test setup already provides `globalThis.chrome`)
- Each result passed into the TestDataProvider must include `_matchScore` property for Fuse.js-migrated sources (tabs, bookmarks, history) so `calculateRelevanceScore` uses the match quality signal
- For history items, include `visitCount` and `lastVisitTime` in the raw data AND in result metadata
- Do NOT test exact score values — test relative ordering and dedup correctness only
  </action>
  <verify>
```bash
npx vitest run test/integration/regression.test.js --reporter=verbose
```
All tests in the new file pass. Then run the full suite:
```bash
npx vitest run
```
Total should be 326 + N new tests (where N is ~11-12), all passing.
  </verify>
  <done>
`test/integration/regression.test.js` exists with 3 describe blocks covering deduplication, Arcify enrichment, and action routing. All new tests pass. Full suite now passes with 326 + N tests. REG-02 is satisfied.
  </done>
</task>

</tasks>

<verification>
1. `npx vitest run --reporter=verbose` — zero failures, 14+ test files pass, 326+ tests pass
2. `test/integration/regression.test.js` exists and contains integration-level behavioral tests
3. Deduplication: same URL from multiple sources → single result with correct type priority
4. Arcify enrichment: pipeline produces `isArcify` metadata on matching URLs
5. Action routing: correct Chrome API called for each result type
</verification>

<success_criteria>
- REG-01: All 326 existing tests pass with zero failures
- REG-02: New integration tests verify deduplication, Arcify enrichment, and action routing work correctly through the full pipeline
- Total test count increased (326 + new regression tests), all passing
</success_criteria>

<output>
After completion, create `.planning/phases/12-regression-validation/12-01-SUMMARY.md`
</output>
