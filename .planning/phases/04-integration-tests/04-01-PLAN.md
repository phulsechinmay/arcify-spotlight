---
phase: 04-integration-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - test/mocks/chrome.js
  - test/integration/setup.js
autonomous: true

must_haves:
  truths:
    - "callListeners() can trigger registered message handlers"
    - "Integration tests run with real timers (not fake timers)"
    - "Module cache is reset between tests for clean imports"
  artifacts:
    - path: "test/mocks/chrome.js"
      provides: "Extended Chrome mock with callListeners support"
      contains: "callListeners"
    - path: "test/integration/setup.js"
      provides: "Integration test setup with real timers"
      contains: "vi.resetModules"
  key_links:
    - from: "test/integration/setup.js"
      to: "test/mocks/chrome.js"
      via: "import chromeMock"
      pattern: "import.*chromeMock.*from.*mocks/chrome"
---

<objective>
Extend Chrome mock infrastructure with callListeners() support and create integration test setup file.

Purpose: Enable realistic message passing simulation where tests trigger handlers via the mocked onMessage.addListener flow (per user decision) rather than calling handlers directly.

Output: Extended test/mocks/chrome.js with callListeners(), test/integration/setup.js with real timers and module reset.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-integration-tests/04-RESEARCH.md

# Existing mock infrastructure
@test/mocks/chrome.js
@test/setup.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Chrome mock with callListeners support</name>
  <files>test/mocks/chrome.js</files>
  <action>
Extend the existing chrome mock with listener tracking and callListeners() method:

1. Add private listener storage array at top of file:
   ```javascript
   let runtimeMessageListeners = [];
   ```

2. Replace chromeMock.runtime.onMessage with extended version:
   ```javascript
   chromeMock.runtime.onMessage = {
     addListener: vi.fn((callback) => {
       runtimeMessageListeners.push(callback);
     }),
     removeListener: vi.fn((callback) => {
       const idx = runtimeMessageListeners.indexOf(callback);
       if (idx > -1) runtimeMessageListeners.splice(idx, 1);
     }),
     hasListener: vi.fn((callback) => runtimeMessageListeners.includes(callback)),
     hasListeners: vi.fn(() => runtimeMessageListeners.length > 0),
     // NEW: Trigger all listeners with given arguments
     callListeners: (message, sender = {}, sendResponse = vi.fn()) => {
       let asyncResponse = false;
       for (const listener of runtimeMessageListeners) {
         const result = listener(message, sender, sendResponse);
         if (result === true) asyncResponse = true;
       }
       return { asyncResponse, sendResponse };
     },
     clearListeners: () => {
       runtimeMessageListeners = [];
     }
   };
   ```

3. Update resetChromeMocks() to clear listeners:
   - Add `runtimeMessageListeners = [];`
   - Add `chromeMock.runtime.onMessage.hasListener.mockClear();`
   - Add `chromeMock.runtime.onMessage.hasListeners.mockClear();`

**Important:** Keep all existing mock functionality. Only ADD to it - do not remove or break existing unit tests.
  </action>
  <verify>
Run `npm test` - all 197 existing unit tests should still pass (no regressions).
  </verify>
  <done>
chromeMock.runtime.onMessage has callListeners() and clearListeners() methods. Existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration test setup file</name>
  <files>test/integration/setup.js</files>
  <action>
Create test/integration/setup.js with integration-specific setup:

```javascript
// test/integration/setup.js
// Integration test setup - uses REAL timers (per user decision)
// This is different from unit test setup which uses fake timers
import { beforeEach, afterEach, vi } from 'vitest';
import { chromeMock, resetChromeMocks } from '../mocks/chrome.js';

// IMPORTANT: Do NOT call vi.useFakeTimers() here
// Integration tests use real timers for realistic behavior

// Set global chrome mock
globalThis.chrome = chromeMock;

// Reset state between tests
beforeEach(() => {
  resetChromeMocks();
  vi.resetModules(); // Clear module cache for fresh imports
});

afterEach(() => {
  chromeMock.runtime.onMessage.clearListeners();
});
```

Create the test/integration/ directory if it doesn't exist.

**Note:** This setup file is imported by integration test files, NOT by vitest.config.js. Each integration test file will import this setup explicitly.
  </action>
  <verify>
1. File exists at test/integration/setup.js
2. Run `npm test` - all tests still pass (setup file doesn't break anything)
  </verify>
  <done>
test/integration/setup.js exists with real timers, chrome mock, and module reset in beforeEach/afterEach.
  </done>
</task>

</tasks>

<verification>
1. `npm test` passes with 197+ tests (no regressions)
2. test/mocks/chrome.js contains callListeners method
3. test/integration/setup.js exists with correct imports
4. No vi.useFakeTimers() in integration setup (per user decision)
</verification>

<success_criteria>
- Chrome mock extended with callListeners() that returns { asyncResponse, sendResponse }
- clearListeners() method available for cleanup
- Integration setup uses real timers (does NOT call vi.useFakeTimers)
- vi.resetModules() called in beforeEach for clean module imports
- All existing 197 tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-integration-tests/04-01-SUMMARY.md`
</output>
