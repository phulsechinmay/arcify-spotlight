---
phase: 03-unit-tests-chrome-api-mocks
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - test/unit/search-engine-debounce.test.js
  - test/unit/action-routing.test.js
autonomous: true

must_haves:
  truths:
    - "Rapid queries within debounce window trigger only one API call"
    - "New query cancels pending debounced query"
    - "Tab switch calls chrome.tabs.update and chrome.windows.update"
    - "New URL in NEW_TAB mode calls chrome.tabs.create"
    - "Search query calls chrome.search.query with correct disposition"
  artifacts:
    - path: "test/unit/search-engine-debounce.test.js"
      provides: "Debounce behavior tests"
      min_lines: 60
    - path: "test/unit/action-routing.test.js"
      provides: "Action routing tests"
      min_lines: 100
  key_links:
    - from: "test/unit/action-routing.test.js"
      to: "test/mocks/chrome.js"
      via: "verifies chrome API calls"
      pattern: "expect.*chromeMock"
    - from: "test/unit/search-engine-debounce.test.js"
      to: "shared/search-engine.js"
      via: "tests debounce mechanism"
      pattern: "advanceTimersByTimeAsync"
---

<objective>
Test SearchEngine debouncing and action routing Chrome API calls.

Purpose: Verify debounce prevents rapid-fire API calls (MOCK-02) and action routing calls correct Chrome APIs (MOCK-03)
Output: Comprehensive debounce and action routing tests
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-unit-tests-chrome-api-mocks/03-RESEARCH.md
@.planning/phases/03-unit-tests-chrome-api-mocks/03-01-SUMMARY.md

@shared/search-engine.js
@shared/search-types.js
@test/mocks/chrome.js
@test/setup.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SearchEngine debounce tests</name>
  <files>test/unit/search-engine-debounce.test.js</files>
  <action>
Create test file for SearchEngine debouncing behavior (MOCK-02).

CRITICAL: Use vi.advanceTimersByTimeAsync() (not sync version) to prevent promise/timer deadlocks.

Test structure:
```javascript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { SearchEngine } from '../../shared/search-engine.js';

describe('SearchEngine debouncing', () => {
    let engine;
    let mockProvider;

    beforeEach(() => {
        vi.useFakeTimers();
        mockProvider = {
            isBackgroundProvider: true,
            getSpotlightSuggestions: vi.fn().mockResolvedValue([])
        };
        engine = new SearchEngine(mockProvider);
    });

    afterEach(() => {
        vi.useRealTimers();
    });

    // Tests go here
});
```

Required test cases:

1. **Rapid queries coalesce to single call:**
   - Fire queries "t", "te", "tes", "test" with 50ms gaps
   - Only final "test" query should trigger provider

2. **New query cancels pending:**
   - Fire "first" query
   - Advance 100ms (partial debounce)
   - Fire "second" query
   - Advance 151ms (full debounce)
   - Only "second" should trigger provider

3. **Query after debounce delay triggers separately:**
   - Fire "first" query
   - Advance 151ms (triggers)
   - Fire "second" query
   - Advance 151ms (triggers)
   - Provider called twice with different queries

4. **Empty query still debounces:**
   - Fire "" empty query
   - Advance 151ms
   - Provider should be called with empty string

Pattern for debounce tests:
```javascript
it('rapid queries within debounce window trigger only one API call', async () => {
    engine.getSpotlightSuggestionsUsingCache('t', 'current-tab');
    await vi.advanceTimersByTimeAsync(50);

    engine.getSpotlightSuggestionsUsingCache('te', 'current-tab');
    await vi.advanceTimersByTimeAsync(50);

    engine.getSpotlightSuggestionsUsingCache('tes', 'current-tab');
    await vi.advanceTimersByTimeAsync(50);

    const promise = engine.getSpotlightSuggestionsUsingCache('test', 'current-tab');
    await vi.advanceTimersByTimeAsync(151);
    await promise;

    expect(mockProvider.getSpotlightSuggestions).toHaveBeenCalledTimes(1);
    expect(mockProvider.getSpotlightSuggestions).toHaveBeenCalledWith('test', 'current-tab');
});
```
  </action>
  <verify>
Run debounce tests:
```bash
npm test -- test/unit/search-engine-debounce.test.js
```
All debounce tests should pass.
  </verify>
  <done>4+ debounce behavior tests passing, verifying rapid query coalescing and timeout cancellation</done>
</task>

<task type="auto">
  <name>Task 2: Create action routing tests</name>
  <files>test/unit/action-routing.test.js</files>
  <action>
Create test file for SearchEngine.handleResultAction Chrome API routing (MOCK-03).

Use table-driven tests with it.each() following established Phase 2 patterns.

Test structure:
```javascript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { SearchEngine } from '../../shared/search-engine.js';
import { ResultType, SpotlightTabMode } from '../../shared/search-types.js';
import { chromeMock, resetChromeMocks } from '../mocks/chrome.js';

describe('SearchEngine.handleResultAction', () => {
    let engine;

    beforeEach(() => {
        resetChromeMocks();
        engine = new SearchEngine({
            isBackgroundProvider: true,
            getSpotlightSuggestions: vi.fn()
        });
    });

    // Tests organized by result type
});
```

Required test groups:

**1. OPEN_TAB result type:**
- NEW_TAB mode: calls chrome.tabs.update(tabId, {active: true}) + chrome.windows.update(windowId, {focused: true})
- CURRENT_TAB mode with currentTabId: calls chrome.tabs.update(currentTabId, {url: ...})
- CURRENT_TAB mode without currentTabId: queries active tab, then updates it

**2. URL_SUGGESTION, BOOKMARK, HISTORY, TOP_SITE result types (same behavior):**
Use it.each to test all four types together:
- NEW_TAB mode: calls chrome.tabs.create({url: ...})
- CURRENT_TAB mode with currentTabId: calls chrome.tabs.update(currentTabId, {url: ...})

```javascript
it.each([
    [ResultType.URL_SUGGESTION],
    [ResultType.BOOKMARK],
    [ResultType.HISTORY],
    [ResultType.TOP_SITE],
])('%s in NEW_TAB mode calls chrome.tabs.create', async (resultType) => {
    const result = { type: resultType, url: 'https://test.com' };
    await engine.handleResultAction(result, SpotlightTabMode.NEW_TAB);
    expect(chromeMock.tabs.create).toHaveBeenCalledWith({ url: 'https://test.com' });
});
```

**3. SEARCH_QUERY result type:**
- NEW_TAB mode: calls chrome.search.query with disposition: 'NEW_TAB'
- CURRENT_TAB mode: calls chrome.search.query with disposition: 'CURRENT_TAB'

```javascript
it('SEARCH_QUERY in NEW_TAB mode calls chrome.search.query', async () => {
    const result = {
        type: ResultType.SEARCH_QUERY,
        metadata: { query: 'test search' }
    };
    await engine.handleResultAction(result, SpotlightTabMode.NEW_TAB);
    expect(chromeMock.search.query).toHaveBeenCalledWith({
        text: 'test search',
        disposition: 'NEW_TAB'
    });
});
```

**4. Error cases:**
- OPEN_TAB without tabId throws
- URL_SUGGESTION without url throws
- SEARCH_QUERY without metadata.query throws
- Unknown result type throws

Focus on background context only (isBackgroundProvider: true). Content script path uses message passing which is Phase 4 scope.
  </action>
  <verify>
Run action routing tests:
```bash
npm test -- test/unit/action-routing.test.js
```
All action routing tests should pass.
  </verify>
  <done>15+ action routing tests passing, covering all result types, both modes, and error cases</done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
npm test
```

Expected: 175+ tests passing (156+ from Plan 01 + 19+ new tests)
</verification>

<success_criteria>
1. Debounce tests verify rapid queries (< 150ms apart) trigger only one API call
2. Debounce tests verify new query cancels pending debounced query
3. Action routing tests verify OPEN_TAB calls chrome.tabs.update for tab switching
4. Action routing tests verify URL types call chrome.tabs.create for NEW_TAB mode
5. Action routing tests verify SEARCH_QUERY calls chrome.search.query with correct disposition
6. All tests pass without flakiness (using async timer advancement)
</success_criteria>

<output>
After completion, create `.planning/phases/03-unit-tests-chrome-api-mocks/03-02-SUMMARY.md`
</output>
