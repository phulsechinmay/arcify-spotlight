---
phase: 06-detection-cache
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/data-providers/arcify-provider.js
  - background.js
autonomous: true

must_haves:
  truths:
    - "Extension detects Arcify folder regardless of Chrome locale or folder location"
    - "URL lookup returns space info in constant time (no recursive traversal per query)"
    - "Adding/removing/moving a bookmark triggers cache refresh within 1 second"
    - "URLs with trailing slashes, www prefix, or protocol variations match correctly"
  artifacts:
    - path: "shared/data-providers/arcify-provider.js"
      provides: "ArcifyProvider class with O(1) URL-to-space lookup"
      exports: ["ArcifyProvider", "arcifyProvider"]
      min_lines: 100
    - path: "background.js"
      provides: "MV3-compliant bookmark event listeners"
      contains: "chrome.bookmarks.onCreated.addListener"
  key_links:
    - from: "shared/data-providers/arcify-provider.js"
      to: "BookmarkUtils.findArcifyFolder()"
      via: "import and call"
      pattern: "BookmarkUtils\\.findArcifyFolder"
    - from: "shared/data-providers/arcify-provider.js"
      to: "chrome.bookmarks.getSubTree()"
      via: "single API call for tree fetch"
      pattern: "chrome\\.bookmarks\\.getSubTree"
    - from: "shared/data-providers/arcify-provider.js"
      to: "BaseDataProvider.normalizeUrlForDeduplication()"
      via: "URL normalization for cache keys"
      pattern: "normalizeUrlForDeduplication"
    - from: "background.js"
      to: "arcifyProvider.invalidateCache()"
      via: "event handler callbacks"
      pattern: "arcifyProvider\\.invalidateCache"
---

<objective>
Create ArcifyProvider class that detects the Arcify bookmark folder and maintains an O(1) URL-to-space mapping cache, with automatic cache invalidation on bookmark changes.

Purpose: Foundation for v1.5 Arcify integration - enables Spotlight to identify which tabs are bookmarked in Arcify spaces and display space chips with correct colors.

Output: ArcifyProvider singleton with getSpaceForUrl() method returning space metadata in constant time, persisted to chrome.storage.local for service worker restart recovery.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-detection-cache/06-RESEARCH.md

# Source files to modify/reference
@shared/data-providers/base-data-provider.js
@bookmark-utils.js
@background.js
@logger.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ArcifyProvider class with O(1) cache</name>
  <files>shared/data-providers/arcify-provider.js</files>
  <action>
Create new ArcifyProvider class following the pattern from 06-RESEARCH.md:

1. Import dependencies:
   - BookmarkUtils from '../../bookmark-utils.js'
   - BaseDataProvider from './base-data-provider.js' (for normalizeUrlForDeduplication)
   - Logger from '../../logger.js'

2. Define CACHE_STORAGE_KEY = 'arcifyUrlCache'

3. Create ArcifyProvider class with:
   - Constructor initializing: cache (null), arcifyFolderId (null), isBuilding (false), buildPromise (null), isImporting (false), pendingInvalidation (false)

   - normalizeUrl(url) method:
     Call BaseDataProvider.prototype.normalizeUrlForDeduplication.call({}, url)
     This reuses existing normalization logic for consistency

   - async getSpaceForUrl(url) method:
     If cache is null, await ensureCacheBuilt()
     Return cache.get(normalizeUrl(url)) or null
     This is the O(1) lookup - just a Map.get()

   - async ensureCacheBuilt() method:
     If cache exists, return immediately
     If buildPromise exists, await it and return
     Set buildPromise = buildCache(), await it, clear buildPromise

   - async buildCache() method:
     If isBuilding, return (guard against concurrent builds)
     Set isBuilding = true
     Try to restore from chrome.storage.local first
     If restored, set cache and arcifyFolderId from storage, return
     Otherwise call rebuildCache()
     Finally set isBuilding = false

   - async rebuildCache() method:
     Call BookmarkUtils.findArcifyFolder() to get folder
     If no folder, set cache = new Map(), arcifyFolderId = null, return
     Set arcifyFolderId = folder.id
     Call chrome.bookmarks.getSubTree(folder.id) - ONE API call
     Create newCache = new Map()
     For each first-level child (space folder):
       Skip if it has a url (it's a bookmark, not folder)
       Create spaceInfo = { spaceName: folder.title, spaceId: folder.id }
       Call processFolder(spaceFolder, spaceInfo, newCache)
     Set cache = newCache
     Call persistCache()
     Log cache size

   - processFolder(folder, spaceInfo, cache) method:
     For each item in folder.children:
       If item.url: cache.set(normalizeUrl(item.url), { ...spaceInfo, bookmarkId: item.id, bookmarkTitle: item.title })
       Else: recurse into processFolder(item, spaceInfo, cache)
     Note: This is in-memory recursion, no API calls

   - async persistCache() method:
     If no cache, return
     Create storageData = { folderId: arcifyFolderId, urlMap: Object.fromEntries(cache), timestamp: Date.now() }
     Call chrome.storage.local.set({ [CACHE_STORAGE_KEY]: storageData })

   - invalidateCache() method:
     If isImporting, set pendingInvalidation = true, return
     Set cache = null
     Call chrome.storage.local.remove(CACHE_STORAGE_KEY)
     Log invalidation

4. Export singleton: export const arcifyProvider = new ArcifyProvider()
5. Export class: export { ArcifyProvider }

IMPORTANT - URL Normalization:
Use the SAME normalizeUrlForDeduplication() that BaseDataProvider uses. This ensures cache keys match lookup keys exactly. The function handles: lowercase, fragment removal, trailing slash removal, protocol removal, www removal.

IMPORTANT - Storage:
Use chrome.storage.local (NOT session). Session storage does NOT survive service worker restarts.
  </action>
  <verify>
File exists at shared/data-providers/arcify-provider.js
Contains ArcifyProvider class export
Contains arcifyProvider singleton export
Contains getSubTree call (not recursive getChildren)
Contains normalizeUrlForDeduplication usage
Contains chrome.storage.local (not session)
  </verify>
  <done>
ArcifyProvider class exists with:
- getSpaceForUrl() returning space info in O(1) via Map lookup
- Cache built from getSubTree() single API call
- Persistence to chrome.storage.local
- URL normalization matching existing deduplication logic
  </done>
</task>

<task type="auto">
  <name>Task 2: Register bookmark event listeners in background.js</name>
  <files>background.js</files>
  <action>
Add MV3-compliant bookmark event listeners to background.js. These MUST be registered synchronously at module top-level per MV3 requirements.

1. Add import at top of file (with other imports):
   import { arcifyProvider } from './shared/data-providers/arcify-provider.js';

2. Add bookmark event listeners SYNCHRONOUSLY at module top-level (not inside any function):

```javascript
// === Arcify Cache Event Listeners ===
// MV3 REQUIREMENT: Register synchronously at top level for service worker restart handling

chrome.bookmarks.onCreated.addListener((id, bookmark) => {
    // Invalidate cache when any bookmark is created
    // The rebuild will determine if it's in Arcify folder
    arcifyProvider.invalidateCache();
});

chrome.bookmarks.onRemoved.addListener((id, removeInfo) => {
    arcifyProvider.invalidateCache();
});

chrome.bookmarks.onMoved.addListener((id, moveInfo) => {
    arcifyProvider.invalidateCache();
});

chrome.bookmarks.onChanged.addListener((id, changeInfo) => {
    arcifyProvider.invalidateCache();
});

// Import batching to prevent cache thrashing during bulk operations
chrome.bookmarks.onImportBegan.addListener(() => {
    arcifyProvider.isImporting = true;
});

chrome.bookmarks.onImportEnded.addListener(() => {
    arcifyProvider.isImporting = false;
    if (arcifyProvider.pendingInvalidation) {
        arcifyProvider.pendingInvalidation = false;
        arcifyProvider.invalidateCache();
    }
});
```

3. Place these listeners AFTER the imports but BEFORE any async initialization code. They must be at module scope, not inside functions.

IMPORTANT - MV3 Compliance:
Event listeners MUST be registered synchronously. If they're inside an async function or callback, the service worker may restart and miss events. The pattern is: import at top, register listeners at top level, handlers can be async internally.

IMPORTANT - Invalidation Strategy:
We invalidate on ANY bookmark change, not just Arcify bookmarks. This is intentional:
- Checking if a bookmark is in Arcify folder requires async operations
- Event handlers should be fast and non-blocking
- The cache rebuild is lazy (happens on next getSpaceForUrl call)
- This avoids complex parent-chain traversal in event handlers
  </action>
  <verify>
background.js contains import for arcifyProvider
background.js contains chrome.bookmarks.onCreated.addListener
background.js contains chrome.bookmarks.onRemoved.addListener
background.js contains chrome.bookmarks.onMoved.addListener
background.js contains chrome.bookmarks.onChanged.addListener
background.js contains chrome.bookmarks.onImportBegan.addListener
background.js contains chrome.bookmarks.onImportEnded.addListener
All listeners are at module top-level (not inside functions)
  </verify>
  <done>
background.js has:
- Import for arcifyProvider singleton
- All 6 bookmark event listeners registered at module top-level
- Import batching handlers for onImportBegan/onImportEnded
- Cache invalidation on any bookmark change
  </done>
</task>

<task type="auto">
  <name>Task 3: Add getArcifySpaceForUrl message handler</name>
  <files>background.js</files>
  <action>
Add a message handler that exposes arcifyProvider.getSpaceForUrl() to content scripts and other extension contexts.

In the main message listener (chrome.runtime.onMessage.addListener), add a new handler:

```javascript
} else if (message.action === 'getArcifySpaceForUrl') {
    (async () => {
        try {
            const spaceInfo = await arcifyProvider.getSpaceForUrl(message.url);
            sendResponse({ success: true, spaceInfo: spaceInfo });
        } catch (error) {
            Logger.error('[Background] Error getting Arcify space for URL:', error);
            sendResponse({ success: false, error: error.message, spaceInfo: null });
        }
    })();
    return true; // Keep channel open for async response
}
```

This handler:
- Receives a URL from content scripts
- Calls arcifyProvider.getSpaceForUrl() which is O(1)
- Returns spaceInfo object with spaceName, spaceId, bookmarkId, bookmarkTitle (or null if not in Arcify)

Note: This handler follows the existing pattern in background.js for async message handlers (wrap in IIFE, return true for async response).
  </action>
  <verify>
background.js contains message handler for 'getArcifySpaceForUrl'
Handler calls arcifyProvider.getSpaceForUrl()
Handler returns spaceInfo in response
Handler follows async response pattern (return true)
  </verify>
  <done>
Message handler exists for 'getArcifySpaceForUrl' that:
- Accepts URL in message
- Returns spaceInfo via arcifyProvider.getSpaceForUrl()
- Uses async response pattern consistent with other handlers
  </done>
</task>

</tasks>

<verification>
After completing all tasks, verify:

1. **DET-01 (Folder Detection):**
   - ArcifyProvider uses BookmarkUtils.findArcifyFolder() which has 3-method fallback
   - Works regardless of Chrome locale or folder location

2. **DET-02 (O(1) Lookup):**
   - getSpaceForUrl() uses Map.get() - constant time
   - No recursive traversal per query
   - Test: Multiple lookups should be instant after initial cache build

3. **DET-03 (Auto-refresh):**
   - All bookmark events trigger invalidateCache()
   - Cache rebuilds lazily on next query
   - Import batching prevents thrashing

4. **DET-04 (URL Normalization):**
   - Uses normalizeUrlForDeduplication() from BaseDataProvider
   - Handles: trailing slashes, www prefix, protocol, fragments

Run build to verify no import/export errors:
```bash
npm run build
```
</verification>

<success_criteria>
- [ ] shared/data-providers/arcify-provider.js exists with ArcifyProvider class
- [ ] ArcifyProvider exports getSpaceForUrl() method
- [ ] Cache uses Map for O(1) lookup
- [ ] getSubTree() used instead of recursive getChildren()
- [ ] normalizeUrlForDeduplication() reused for URL normalization
- [ ] chrome.storage.local used for persistence (not session)
- [ ] All 6 bookmark event listeners registered in background.js
- [ ] Event listeners at module top-level (MV3 compliance)
- [ ] getArcifySpaceForUrl message handler added
- [ ] npm run build succeeds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-detection-cache/06-01-SUMMARY.md` following the summary template.
</output>
