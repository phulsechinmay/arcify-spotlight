---
phase: 10-weighted-scoring-system
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - test/unit/scoring.test.js
autonomous: true

must_haves:
  truths:
    - "All scoring tests pass with the new weighted formula"
    - "Type hierarchy is verified: open tab > pinned tab > bookmark > history > top site for same matchScore"
    - "Recency signal is verified: recent history outranks old history"
    - "Frequency signal is verified: high visit count outranks low visit count"
    - "Autocomplete boost is verified: boost applies when local results sparse, not when plentiful"
    - "Weight redistribution is verified: non-history types score in full 0-115 range"
  artifacts:
    - path: "test/unit/scoring.test.js"
      provides: "Complete test coverage for weighted multi-signal scoring"
      min_lines: 200
  key_links:
    - from: "test/unit/scoring.test.js"
      to: "shared/data-providers/base-data-provider.js"
      via: "provider.calculateRelevanceScore() calls in test assertions"
      pattern: "provider\\.calculateRelevanceScore"
    - from: "test/unit/scoring.test.js"
      to: "shared/scoring-constants.js"
      via: "import of new constants for test assertions"
      pattern: "import.*SCORING_WEIGHTS.*scoring-constants"
---

<objective>
Update all scoring tests for the new weighted multi-signal formula and add new test suites for recency, frequency, autocomplete boost, and weight redistribution.

Purpose: The existing 30+ tests in scoring.test.js assert against the old `base + matchScore * 25` formula. These need updating to match the new weighted formula output. Additionally, new test suites must verify the 4 new behaviors: recency signal, frequency signal, autocomplete boost, and weight redistribution for non-history types.

Output: All tests green. Full coverage of SCORE-01 through SCORE-05 requirements.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-weighted-scoring-system/10-RESEARCH.md
@.planning/phases/10-weighted-scoring-system/10-01-SUMMARY.md
@shared/scoring-constants.js
@shared/data-providers/base-data-provider.js
@test/unit/scoring.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update existing scoring tests for new weighted formula</name>
  <files>test/unit/scoring.test.js</files>
  <action>
Update the imports at the top of the test file to include new exports:
```javascript
import {
    BASE_SCORES,
    SCORE_BONUSES,
    SCORING_WEIGHTS,
    TYPE_SCORE_MAP,
    SCORE_SCALE,
    calculateRecencyScore,
    calculateFrequencyScore,
    AUTOCOMPLETE_BOOST_MAX,
    LOCAL_RESULT_THRESHOLD,
    getAutocompleteScore,
    getFuzzyMatchScore
} from '../../shared/scoring-constants.js';
```

**Existing test suites to update:**

1. **"base scores by result type"** - These tests use `{ type, title: 'Test', url: 'https://test.com' }` with query `'nomatch'`. With the new formula, results without matchScore get a synthetic matchScore. Since 'Test' does not contain 'nomatch' and 'test.com' does not contain 'nomatch', the synthetic score is 0.1 (baseline). The expected score becomes: `(effectiveTypeWeight * typeScore + effectiveMatchWeight * 0.1) * SCORE_SCALE` for non-history types. For history type, all 4 weights apply but recency=0, frequency=0: `(TYPE_W * 0.778 + MATCH_W * 0.1 + RECENCY_W * 0 + FREQUENCY_W * 0) * 115`.

   Instead of asserting exact numeric values, use comparison-based assertions to verify the TYPE HIERARCHY is preserved:
   - `openTabScore > pinnedTabScore > bookmarkScore > historyScore > topSiteScore`
   - Each score > 0
   - Each score <= SCORE_SCALE (115)

   This is more robust than hardcoding exact values that will break with any weight tuning.

2. **"title match bonuses" and "URL match bonuses" and "combined bonuses"** - These tests verify string matching behavior. With the new formula, string matching produces a synthetic matchScore (not additive bonuses). Update these tests to verify RELATIVE ordering rather than exact values:
   - Exact title match > title starts with > title contains > URL only contains > no match
   - Same type, different match quality -> higher match quality = higher score

3. **"matchScore integration"** - These tests verify Fuse.js matchScore behavior. Update:
   - `matchScore: 0.9` with type `open-tab` -> score = `(0.533 * 1.0 + 0.467 * 0.9) * 115`. Use `toBeCloseTo()` for float comparison.
   - `matchScore: 1.0` with type `bookmark` -> score = `(0.533 * 0.889 + 0.467 * 1.0) * 115`
   - "preserves type hierarchy even with matchScore" -> keep as-is (comparison test, should still pass)
   - "skips string matching bonuses when matchScore is present" -> verify score uses matchScore, not synthetic. Compare: result with matchScore 0.95 should produce different score than same result without matchScore (which would use synthetic).
   - "falls back to string matching when matchScore is null" -> verify result still gets a reasonable score (synthetic matchScore path).
   - "does not add bonus when matchScore is 0" -> with new formula, matchScore=0 falls to synthetic path. Verify score > 0 (type still contributes).

4. **"case insensitivity"** - These should still work since synthetic matchScore uses case-insensitive comparison. Verify via relative assertions.

5. **"minimum score enforcement"** - Keep: unknown type should produce score >= 0.

6. **"BASE_SCORES constants"** and **"SCORE_BONUSES constants"** - Keep unchanged. These test constant values, not the formula.

7. **"getAutocompleteScore"** and **"getFuzzyMatchScore"** test suites - Keep unchanged. These test utility functions that still exist.

**Key principle for updated tests:** Use RELATIVE assertions (`toBeGreaterThan`, `toBeLessThan`) for formula output tests. Use `toBeCloseTo(expected, 0)` (0 decimal places = within 0.5) for tests that verify specific formula behavior. This makes tests resilient to minor weight tuning.
  </action>
  <verify>Run `npx vitest run test/unit/scoring.test.js` -- all existing (updated) tests should pass.</verify>
  <done>All pre-existing test suites updated to work with weighted formula. Tests use relative assertions where possible for resilience to weight tuning.</done>
</task>

<task type="auto">
  <name>Task 2: Add new test suites for recency, frequency, autocomplete boost, and weight redistribution</name>
  <files>test/unit/scoring.test.js</files>
  <action>
Add the following NEW describe blocks to `scoring.test.js`:

**1. "calculateRecencyScore helper"**
```javascript
describe('calculateRecencyScore', () => {
    it('returns ~1 for visit just now', () => {
        expect(calculateRecencyScore(Date.now())).toBeCloseTo(1, 1);
    });

    it('returns ~0.5 for visit 24 hours ago (half-life)', () => {
        const oneDayAgo = Date.now() - 24 * 60 * 60 * 1000;
        expect(calculateRecencyScore(oneDayAgo)).toBeCloseTo(0.5, 1);
    });

    it('returns near 0 for visit 7 days ago', () => {
        const sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
        expect(calculateRecencyScore(sevenDaysAgo)).toBeLessThan(0.01);
    });

    it('returns 0 for null/undefined lastVisitTime', () => {
        expect(calculateRecencyScore(null)).toBe(0);
        expect(calculateRecencyScore(undefined)).toBe(0);
    });

    it('returns 1 for future timestamp (clock skew)', () => {
        expect(calculateRecencyScore(Date.now() + 60000)).toBe(1);
    });

    it('more recent visit scores higher than older visit', () => {
        const fiveMinAgo = Date.now() - 5 * 60 * 1000;
        const sixHoursAgo = Date.now() - 6 * 60 * 60 * 1000;
        expect(calculateRecencyScore(fiveMinAgo)).toBeGreaterThan(calculateRecencyScore(sixHoursAgo));
    });
});
```

**2. "calculateFrequencyScore helper"**
```javascript
describe('calculateFrequencyScore', () => {
    it('returns 0 for visitCount 0', () => {
        expect(calculateFrequencyScore(0)).toBe(0);
    });

    it('returns 0 for null/undefined visitCount', () => {
        expect(calculateFrequencyScore(null)).toBe(0);
        expect(calculateFrequencyScore(undefined)).toBe(0);
    });

    it('returns 1 for visitCount >= 100 (cap)', () => {
        expect(calculateFrequencyScore(100)).toBeCloseTo(1, 2);
        expect(calculateFrequencyScore(500)).toBe(1); // capped
    });

    it('higher visit count produces higher score', () => {
        expect(calculateFrequencyScore(50)).toBeGreaterThan(calculateFrequencyScore(10));
        expect(calculateFrequencyScore(10)).toBeGreaterThan(calculateFrequencyScore(2));
    });

    it('returns value between 0 and 1 for typical counts', () => {
        const score = calculateFrequencyScore(25);
        expect(score).toBeGreaterThan(0);
        expect(score).toBeLessThan(1);
    });
});
```

**3. "weighted scoring - type hierarchy preserved (SCORE-02)"**
```javascript
describe('weighted scoring - type hierarchy preserved (SCORE-02)', () => {
    let provider;

    beforeEach(() => {
        provider = Object.create(BaseDataProvider.prototype);
    });

    it('open tab with moderate match outranks bookmark with perfect match', () => {
        const openTab = {
            type: 'open-tab', title: 'GitHub Dashboard',
            url: 'https://github.com', metadata: { matchScore: 0.6 }
        };
        const bookmark = {
            type: 'bookmark', title: 'GitHub',
            url: 'https://github.com', metadata: { matchScore: 1.0 }
        };
        expect(provider.calculateRelevanceScore(openTab, 'github'))
            .toBeGreaterThan(provider.calculateRelevanceScore(bookmark, 'github'));
    });

    it('open tab outranks history with perfect match and recent visit', () => {
        const openTab = {
            type: 'open-tab', title: 'GitHub',
            url: 'https://github.com', metadata: { matchScore: 0.6 }
        };
        const history = {
            type: 'history', title: 'GitHub',
            url: 'https://github.com',
            metadata: { matchScore: 1.0, lastVisitTime: Date.now() - 5 * 60 * 1000, visitCount: 50 }
        };
        expect(provider.calculateRelevanceScore(openTab, 'github'))
            .toBeGreaterThan(provider.calculateRelevanceScore(history, 'github'));
    });

    it('full type hierarchy for same matchScore', () => {
        const makeResult = (type, extra = {}) => ({
            type, title: 'GitHub', url: 'https://github.com',
            metadata: { matchScore: 0.8, ...extra }
        });
        const scores = {
            openTab: provider.calculateRelevanceScore(makeResult('open-tab'), 'github'),
            pinnedTab: provider.calculateRelevanceScore(makeResult('pinned-tab'), 'github'),
            bookmark: provider.calculateRelevanceScore(makeResult('bookmark'), 'github'),
            history: provider.calculateRelevanceScore(
                makeResult('history', { lastVisitTime: Date.now() - 60000, visitCount: 10 }), 'github'
            ),
            topSite: provider.calculateRelevanceScore(makeResult('top-site'), 'github'),
        };
        expect(scores.openTab).toBeGreaterThan(scores.pinnedTab);
        expect(scores.pinnedTab).toBeGreaterThan(scores.bookmark);
        expect(scores.bookmark).toBeGreaterThan(scores.history);
        expect(scores.history).toBeGreaterThan(scores.topSite);
    });
});
```

**4. "weighted scoring - recency signal (SCORE-03)"**
```javascript
describe('weighted scoring - recency signal (SCORE-03)', () => {
    let provider;

    beforeEach(() => {
        provider = Object.create(BaseDataProvider.prototype);
    });

    it('history visited 5 min ago outranks same page visited 3 weeks ago', () => {
        const recent = {
            type: 'history', title: 'Jira Board', url: 'https://jira.example.com',
            metadata: { matchScore: 0.8, lastVisitTime: Date.now() - 5 * 60 * 1000, visitCount: 5 }
        };
        const old = {
            type: 'history', title: 'Jira Board', url: 'https://jira.example.com/old',
            metadata: { matchScore: 0.8, lastVisitTime: Date.now() - 21 * 24 * 60 * 60 * 1000, visitCount: 5 }
        };
        expect(provider.calculateRelevanceScore(recent, 'jira'))
            .toBeGreaterThan(provider.calculateRelevanceScore(old, 'jira'));
    });

    it('recency has no effect on non-history types', () => {
        // Bookmarks don't use recency, so lastVisitTime in metadata is ignored
        const bookmark1 = {
            type: 'bookmark', title: 'GitHub', url: 'https://github.com',
            metadata: { matchScore: 0.8, lastVisitTime: Date.now() }
        };
        const bookmark2 = {
            type: 'bookmark', title: 'GitHub', url: 'https://github.com',
            metadata: { matchScore: 0.8 }
        };
        expect(provider.calculateRelevanceScore(bookmark1, 'github'))
            .toBe(provider.calculateRelevanceScore(bookmark2, 'github'));
    });
});
```

**5. "weighted scoring - frequency signal (SCORE-04)"**
```javascript
describe('weighted scoring - frequency signal (SCORE-04)', () => {
    let provider;

    beforeEach(() => {
        provider = Object.create(BaseDataProvider.prototype);
    });

    it('history with 50 visits outranks same with 2 visits', () => {
        const frequent = {
            type: 'history', title: 'Docs', url: 'https://docs.example.com',
            metadata: { matchScore: 0.8, lastVisitTime: Date.now() - 3600000, visitCount: 50 }
        };
        const infrequent = {
            type: 'history', title: 'Docs', url: 'https://docs.example.com/other',
            metadata: { matchScore: 0.8, lastVisitTime: Date.now() - 3600000, visitCount: 2 }
        };
        expect(provider.calculateRelevanceScore(frequent, 'docs'))
            .toBeGreaterThan(provider.calculateRelevanceScore(infrequent, 'docs'));
    });
});
```

**6. "weighted scoring - autocomplete boost (SCORE-05)"**
```javascript
describe('weighted scoring - autocomplete boost (SCORE-05)', () => {
    let provider;

    beforeEach(() => {
        provider = Object.create(BaseDataProvider.prototype);
    });

    it('boosts autocomplete when 0 local results', () => {
        const autocomplete = {
            type: 'autocomplete-suggestion', title: 'test query',
            url: '', score: 30, metadata: {}
        };
        const results = [autocomplete];
        const sorted = provider.scoreAndSortResults(results, 'test');
        // With 0 local results, boost = AUTOCOMPLETE_BOOST_MAX * (3/3) = 40
        // Final score = 30 + 40 = 70
        expect(sorted[0].score).toBeCloseTo(30 + AUTOCOMPLETE_BOOST_MAX, 0);
    });

    it('partially boosts autocomplete when 1 local result', () => {
        const local = {
            type: 'history', title: 'test page', url: 'https://test.com',
            metadata: { matchScore: 0.8, lastVisitTime: Date.now(), visitCount: 5 }
        };
        const autocomplete = {
            type: 'autocomplete-suggestion', title: 'test query',
            url: '', score: 30, metadata: {}
        };
        const results = [local, autocomplete];
        const sorted = provider.scoreAndSortResults(results, 'test');
        const acResult = sorted.find(r => r.type === 'autocomplete-suggestion');
        // With 1 local result, boost = 40 * (2/3) ~= 26.67
        expect(acResult.score).toBeGreaterThan(30);
        expect(acResult.score).toBeLessThan(30 + AUTOCOMPLETE_BOOST_MAX);
    });

    it('does not boost autocomplete when 3+ local results', () => {
        const makeLocal = (i) => ({
            type: 'history', title: `page ${i}`, url: `https://test${i}.com`,
            metadata: { matchScore: 0.5, lastVisitTime: Date.now(), visitCount: 3 }
        });
        const autocomplete = {
            type: 'autocomplete-suggestion', title: 'test query',
            url: '', score: 30, metadata: {}
        };
        const results = [makeLocal(1), makeLocal(2), makeLocal(3), autocomplete];
        const sorted = provider.scoreAndSortResults(results, 'test');
        const acResult = sorted.find(r => r.type === 'autocomplete-suggestion');
        expect(acResult.score).toBe(30); // No boost applied
    });
});
```

**7. "weighted scoring - non-history weight redistribution"**
```javascript
describe('weighted scoring - non-history weight redistribution', () => {
    let provider;

    beforeEach(() => {
        provider = Object.create(BaseDataProvider.prototype);
    });

    it('non-history type with perfect match scores at SCORE_SCALE', () => {
        const result = {
            type: 'open-tab', title: 'GitHub', url: 'https://github.com',
            metadata: { matchScore: 1.0 }
        };
        const score = provider.calculateRelevanceScore(result, 'github');
        // (0.533 * 1.0 + 0.467 * 1.0) * 115 = 115
        expect(score).toBeCloseTo(SCORE_SCALE, 0);
    });

    it('non-history types can reach full score range', () => {
        const perfect = {
            type: 'open-tab', title: 'Test', url: 'https://test.com',
            metadata: { matchScore: 1.0 }
        };
        const weak = {
            type: 'top-site', title: 'Something', url: 'https://something.com',
            metadata: { matchScore: 0.2 }
        };
        const perfectScore = provider.calculateRelevanceScore(perfect, 'test');
        const weakScore = provider.calculateRelevanceScore(weak, 'something');
        // Good spread across the range
        expect(perfectScore).toBeGreaterThan(100);
        expect(weakScore).toBeLessThan(60);
    });
});
```

**8. Add a "SCORING_WEIGHTS constants" describe block:**
```javascript
describe('SCORING_WEIGHTS constants', () => {
    it('weights sum to 1.0', () => {
        const sum = SCORING_WEIGHTS.TYPE + SCORING_WEIGHTS.MATCH +
                    SCORING_WEIGHTS.RECENCY + SCORING_WEIGHTS.FREQUENCY;
        expect(sum).toBeCloseTo(1.0, 5);
    });

    it('TYPE weight is the largest (preserves hierarchy)', () => {
        expect(SCORING_WEIGHTS.TYPE).toBeGreaterThan(SCORING_WEIGHTS.MATCH);
        expect(SCORING_WEIGHTS.TYPE).toBeGreaterThan(SCORING_WEIGHTS.RECENCY);
        expect(SCORING_WEIGHTS.TYPE).toBeGreaterThan(SCORING_WEIGHTS.FREQUENCY);
    });
});
```
  </action>
  <verify>Run `npx vitest run test/unit/scoring.test.js` -- ALL tests pass (0 failures). Count total tests: should be 40+ (original ~35 updated + 8 new describe blocks with ~25 new tests).</verify>
  <done>All scoring tests pass. New test suites cover: calculateRecencyScore helper, calculateFrequencyScore helper, type hierarchy with weighted formula (SCORE-02), recency signal (SCORE-03), frequency signal (SCORE-04), autocomplete boost (SCORE-05), weight redistribution for non-history types, and SCORING_WEIGHTS constants validation.</done>
</task>

</tasks>

<verification>
1. `npx vitest run test/unit/scoring.test.js` passes with 0 failures
2. Type hierarchy test confirms: open tab > pinned tab > bookmark > history > top site
3. Recency test confirms: 5 min ago > 3 weeks ago for same history item
4. Frequency test confirms: 50 visits > 2 visits for same history item
5. Autocomplete boost test confirms: boost when 0 local, partial when 1 local, none when 3+ local
6. Weight redistribution test confirms: non-history types can reach full SCORE_SCALE
7. Helper function tests cover edge cases (null, 0, negative, cap)
</verification>

<success_criteria>
- `npx vitest run test/unit/scoring.test.js` exits with 0 failures
- All 5 SCORE requirements have corresponding test coverage:
  - SCORE-01: weighted formula tests (base scores, matchScore integration updated)
  - SCORE-02: type hierarchy preservation tests
  - SCORE-03: recency signal tests
  - SCORE-04: frequency signal tests
  - SCORE-05: autocomplete boost tests
- No other test files broken (run `npx vitest run` for full suite if time permits)
</success_criteria>

<output>
After completion, create `.planning/phases/10-weighted-scoring-system/10-02-SUMMARY.md`
</output>
