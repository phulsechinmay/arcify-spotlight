---
phase: 10-weighted-scoring-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/scoring-constants.js
  - shared/data-providers/base-data-provider.js
autonomous: true

must_haves:
  truths:
    - "Results are ordered by a combined score weighing type, match quality, recency, and frequency"
    - "Open tabs still appear above bookmarks and history for equally strong matches"
    - "A history page visited 5 minutes ago ranks higher than the same page visited 3 weeks ago"
    - "A history page visited 50 times ranks higher than one visited twice for the same query"
    - "Autocomplete suggestions appear in results when few local matches exist"
  artifacts:
    - path: "shared/scoring-constants.js"
      provides: "Scoring weights, type score map, recency/frequency helpers, autocomplete boost constants"
      exports: ["SCORING_WEIGHTS", "TYPE_SCORE_MAP", "SCORE_SCALE", "calculateRecencyScore", "calculateFrequencyScore", "AUTOCOMPLETE_BOOST_MAX", "LOCAL_RESULT_THRESHOLD"]
    - path: "shared/data-providers/base-data-provider.js"
      provides: "Weighted multi-signal calculateRelevanceScore and autocomplete boost in scoreAndSortResults"
      contains: "SCORING_WEIGHTS"
  key_links:
    - from: "shared/data-providers/base-data-provider.js"
      to: "shared/scoring-constants.js"
      via: "import SCORING_WEIGHTS, TYPE_SCORE_MAP, calculateRecencyScore, calculateFrequencyScore"
      pattern: "import.*SCORING_WEIGHTS.*scoring-constants"
    - from: "calculateRelevanceScore"
      to: "result.metadata.lastVisitTime"
      via: "recency signal for history results"
      pattern: "calculateRecencyScore.*lastVisitTime"
    - from: "calculateRelevanceScore"
      to: "result.metadata.visitCount"
      via: "frequency signal for history results"
      pattern: "calculateFrequencyScore.*visitCount"
    - from: "scoreAndSortResults"
      to: "AUTOCOMPLETE_BOOST_MAX"
      via: "conditional boost when local results sparse"
      pattern: "AUTOCOMPLETE_BOOST_MAX.*boostFactor"
---

<objective>
Implement the weighted multi-signal scoring formula and autocomplete boost.

Purpose: Replace the flat `base + matchScore * 25` scoring with a principled weighted formula that combines type priority, Fuse.js match quality, recency (for history), and frequency (for history). Also add conditional autocomplete boost when local results are sparse.

Output: Refactored `calculateRelevanceScore()` using 4-signal weighted formula, plus `applyAutocompleteBoost()` in the scoring pipeline. All scoring weights/helpers as named constants.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-weighted-scoring-system/10-RESEARCH.md
@shared/scoring-constants.js
@shared/data-providers/base-data-provider.js
@shared/search-types.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scoring weights, helpers, and type score map to scoring-constants.js</name>
  <files>shared/scoring-constants.js</files>
  <action>
Add the following named exports to `scoring-constants.js` (keep all existing exports unchanged):

1. **SCORING_WEIGHTS object:**
```javascript
export const SCORING_WEIGHTS = {
    TYPE:      0.40,
    MATCH:     0.35,
    RECENCY:   0.15,
    FREQUENCY: 0.10,
};
```

2. **TYPE_SCORE_MAP** - normalized 0-1 type scores derived from BASE_SCORES:
```javascript
export const TYPE_SCORE_MAP = {
    [ResultType.OPEN_TAB]:    1.0,
    [ResultType.PINNED_TAB]:  0.944,
    [ResultType.BOOKMARK]:    0.889,
    [ResultType.HISTORY]:     0.778,
    [ResultType.TOP_SITE]:    0.667,
};
```
Import `ResultType` from `../shared/search-types.js` (adjust path: since scoring-constants.js is in shared/, import from `./search-types.js`).

3. **SCORE_SCALE** constant:
```javascript
export const SCORE_SCALE = 115;
```

4. **calculateRecencyScore** helper function:
```javascript
export const RECENCY_HALF_LIFE_HOURS = 24;

export function calculateRecencyScore(lastVisitTime) {
    if (!lastVisitTime) return 0;
    const ageHours = (Date.now() - lastVisitTime) / (1000 * 60 * 60);
    if (ageHours < 0) return 1; // Clock skew protection
    return Math.pow(0.5, ageHours / RECENCY_HALF_LIFE_HOURS);
}
```

5. **calculateFrequencyScore** helper function:
```javascript
export const FREQUENCY_LOG_CAP = Math.log1p(100);

export function calculateFrequencyScore(visitCount) {
    if (!visitCount || visitCount <= 0) return 0;
    return Math.min(1, Math.log1p(visitCount) / FREQUENCY_LOG_CAP);
}
```

6. **Autocomplete boost constants:**
```javascript
export const AUTOCOMPLETE_BOOST_MAX = 40;
export const LOCAL_RESULT_THRESHOLD = 3;
```

Keep all existing exports (BASE_SCORES, SCORE_BONUSES, getAutocompleteScore, getFuzzyMatchScore) exactly as they are. The existing code continues to function -- we are adding new exports, not replacing old ones.
  </action>
  <verify>
Run `node -e "import('./shared/scoring-constants.js').then(m => { console.log('SCORING_WEIGHTS:', m.SCORING_WEIGHTS); console.log('TYPE_SCORE_MAP:', m.TYPE_SCORE_MAP); console.log('SCORE_SCALE:', m.SCORE_SCALE); console.log('recency(now):', m.calculateRecencyScore(Date.now())); console.log('frequency(50):', m.calculateFrequencyScore(50)); console.log('AUTOCOMPLETE_BOOST_MAX:', m.AUTOCOMPLETE_BOOST_MAX); })"` -- all values print correctly. Existing exports still work: `console.log('BASE_SCORES:', m.BASE_SCORES)` should print the unchanged BASE_SCORES object.
  </verify>
  <done>scoring-constants.js exports SCORING_WEIGHTS, TYPE_SCORE_MAP, SCORE_SCALE, calculateRecencyScore, calculateFrequencyScore, AUTOCOMPLETE_BOOST_MAX, LOCAL_RESULT_THRESHOLD alongside all existing exports unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor calculateRelevanceScore to weighted formula and add autocomplete boost</name>
  <files>shared/data-providers/base-data-provider.js</files>
  <action>
Two changes in `base-data-provider.js`:

**Change 1: Refactor `calculateRelevanceScore()`**

Replace the current `calculateRelevanceScore` method with the weighted multi-signal formula. The new method must:

1. **Autocomplete early return:** If `result.type === ResultType.AUTOCOMPLETE_SUGGESTION`, return `result.score || BASE_SCORES.AUTOCOMPLETE_SUGGESTION` unchanged. Autocomplete has its own scoring path.

2. **Compute typeScore:** Use `TYPE_SCORE_MAP[result.type] || 0` for the normalized 0-1 type signal.

3. **Compute matchQuality:** Use `result.metadata?.matchScore` if available and > 0. If matchScore is null/undefined/0, compute a **synthetic matchScore** from string matching:
   - Exact title match (case-insensitive) -> 1.0
   - Title starts with query -> 0.8
   - Title contains query -> 0.6
   - URL contains query -> 0.3
   - None of the above -> 0.1 (result passed some filter to get here)
   Note: these string-match checks should evaluate title AND URL independently. For the synthetic score, take the HIGHEST applicable value (not additive). For example, if title contains AND url contains, syntheticScore = 0.6 (title contains is higher).

4. **Compute recencyScore:** Only for `result.type === ResultType.HISTORY`. Call `calculateRecencyScore(result.metadata?.lastVisitTime)`. For non-history types, recencyScore = 0.

5. **Compute frequencyScore:** Only for `result.type === ResultType.HISTORY`. Call `calculateFrequencyScore(result.metadata?.visitCount)`. For non-history types, frequencyScore = 0.

6. **Compute weighted score with weight redistribution:**
   - For history types: all 4 weights apply (sum = 1.0), use them directly.
   - For non-history types: only TYPE and MATCH apply. Redistribute by dividing each by their sum (0.75):
     - effectiveTypeWeight = SCORING_WEIGHTS.TYPE / (SCORING_WEIGHTS.TYPE + SCORING_WEIGHTS.MATCH)
     - effectiveMatchWeight = SCORING_WEIGHTS.MATCH / (SCORING_WEIGHTS.TYPE + SCORING_WEIGHTS.MATCH)
   - Compute: `weightedScore = effectiveTypeWeight * typeScore + effectiveMatchWeight * matchQuality + (isHistory ? SCORING_WEIGHTS.RECENCY * recencyScore + SCORING_WEIGHTS.FREQUENCY * frequencyScore : 0)`

7. **Scale and return:** `return Math.max(0, weightedScore * SCORE_SCALE)`

Update the import at the top of the file to include the new exports:
```javascript
import { BASE_SCORES, SCORE_BONUSES, SCORING_WEIGHTS, TYPE_SCORE_MAP, SCORE_SCALE, calculateRecencyScore, calculateFrequencyScore, AUTOCOMPLETE_BOOST_MAX, LOCAL_RESULT_THRESHOLD } from '../scoring-constants.js';
```

Note: Keep `SCORE_BONUSES` in the import even though the main formula no longer uses it -- it may still be referenced elsewhere or in future use. Actually, check if SCORE_BONUSES is used anywhere else in the file. If not, it can be removed from the import. But keeping it is harmless.

**Change 2: Add autocomplete boost in `scoreAndSortResults()`**

After scoring all results but BEFORE sorting, add the autocomplete boost logic:

```javascript
scoreAndSortResults(results, query) {
    // Score all results
    results.forEach(result => {
        result.score = this.calculateRelevanceScore(result, query);
    });

    // Apply conditional autocomplete boost (SCORE-05)
    const localCount = results.filter(r =>
        r.type !== ResultType.AUTOCOMPLETE_SUGGESTION
    ).length;

    if (localCount < LOCAL_RESULT_THRESHOLD) {
        const boostFactor = (LOCAL_RESULT_THRESHOLD - localCount) / LOCAL_RESULT_THRESHOLD;
        results.forEach(r => {
            if (r.type === ResultType.AUTOCOMPLETE_SUGGESTION) {
                r.score += AUTOCOMPLETE_BOOST_MAX * boostFactor;
            }
        });
    }

    // Sort and limit
    const sorted = results
        .sort((a, b) => b.score - a.score)
        .slice(0, 8);

    return sorted;
}
```

**Important: Do NOT change any other methods** in base-data-provider.js. The `getResultPriority()` method uses `BASE_SCORES` for deduplication priority -- leave it as-is. The deduplication runs BEFORE scoring, so it uses type-based priority only, which is correct.
  </action>
  <verify>
Run `npx vitest run test/unit/scoring.test.js` -- some existing tests WILL fail because expected values changed (this is expected; Plan 02 updates the tests). The key verification is that the file loads without syntax/import errors. Verify with: `node -e "import('./shared/data-providers/base-data-provider.js').then(() => console.log('Import OK')).catch(e => console.error('Import FAILED:', e.message))"` -- should print "Import OK".

Spot-check the formula manually:
- Open tab (matchScore 0.8): typeScore=1.0, matchQuality=0.8, non-history redistribution -> (0.533 * 1.0 + 0.467 * 0.8) * 115 = (0.533 + 0.374) * 115 = 0.907 * 115 = ~104.3
- History (matchScore 0.9, 5min ago, 50 visits): (0.40*0.778 + 0.35*0.9 + 0.15*0.997 + 0.10*0.852) * 115 = (0.311+0.315+0.150+0.085)*115 = 0.861*115 = ~99.0
  </verify>
  <done>calculateRelevanceScore uses 4-signal weighted formula with weight redistribution for non-history types. scoreAndSortResults applies conditional autocomplete boost when local results < 3. File imports and loads cleanly.</done>
</task>

</tasks>

<verification>
1. `shared/scoring-constants.js` exports all new constants and helpers alongside existing exports
2. `shared/data-providers/base-data-provider.js` imports new exports and uses weighted formula
3. Both files load without import/syntax errors
4. calculateRelevanceScore produces scores in 0-115 range (backward compatible)
5. Autocomplete boost applies only when local results < LOCAL_RESULT_THRESHOLD
6. Non-history types use redistributed weights (TYPE 0.533, MATCH 0.467)
7. History types use all 4 signals with original weights
</verification>

<success_criteria>
- calculateRelevanceScore returns weighted multi-signal scores for all result types
- Type hierarchy preserved: open tab (moderate match) > bookmark (perfect match) for same query
- History results incorporate recency and frequency signals
- Autocomplete results get conditional boost in scoreAndSortResults when local results sparse
- All constants are named exports in scoring-constants.js (no magic numbers)
- Score output range 0-115 for backward compatibility with deduplication priority
</success_criteria>

<output>
After completion, create `.planning/phases/10-weighted-scoring-system/10-01-SUMMARY.md`
</output>
